[[phoenixs-basics]]
# Phoenix's Basics
Stefan Wintermeyer <sw@wintermeyer-consulting.de>

Phoenix follows the
https://en.wikipedia.org/wiki/Model–view–controller[Model-View-Controller] (MVC)
architecture. If you are not familiar with that: Just follow my lead. MVC is
just a set of rules of what goes where so that everybody knows where stuff is.
You are not forced to follow it but it makes live easier if you do. After a
couple of examples you'll get a feeling for it. Same goes for the directory
structure and the file names.

In this chapter I'll show you how you can create simple webpages which have some
programming logic. But we will not touch the database yet. Step by step!

[IMPORTANT]
.Phoenix version
====
The code examples of this book are written and tested for Phoenix
version 1.5.1 or above. Please make sure that you have a 1.5.x version
installed.
[source,bash]
----
$ mix phx.new --version
Phoenix v1.5.1
----
====

## Development Environment

By default Phoenix offers three different environments:

- Development
- Testing
- Production

In this chapter we are only going to use the development environment. It offers some pleasantries which make the life of a developer easier (e.g. more verbose error messages and auto reload after code changes).

[[the-base-setup]]
## The Base Setup

The base of every Phoenix application is created with the command
`mix phx.new application_name` which generates all needed files and the
directory structure.

We call our new application `demo`:

[source,bash]
----
$ mix phx.new demo --no-ecto <1>
* creating demo/config/config.exs
* creating demo/config/dev.exs
[...]
Fetch and install dependencies? [Yn] Y <2>
[...]
We are almost there! The following steps are missing:

    $ cd hello_world

Start your Phoenix app with:

    $ mix phx.server

You can also run your app inside IEx (Interactive Elixir) as:

    $ iex -S mix phx.server
----
<1> '--no-ecto' creates a fresh application without the Ecto (database connector) part. We don't need a database for the basic examples.
<2> You always want to press `Y` here. And yes, it sometimes takes for ever.

After that we `cd demo` into the new directory and fire up the Phoenix server 
with `mix phx.server`

[source,bash]
----
$ cd demo
$ mix phx.server
Compiling 13 files (.ex) <1>
Generated demo app
[info] Running DemoWeb.Endpoint with cowboy 2.7.0 at 0.0.0.0:4000 (http)
[info] Access DemoWeb.Endpoint at http://localhost:4000 <2>

webpack is watching the files…

Hash: f3ee21a2f5780f52f176
Version: webpack 4.41.5
[...]
----
<1> Source-Code which hasn't been compiled yet is compiled.
<2> The URL which service the development website: http://localhost:4000

Please open the URL http://localhost:4000 in your webbrowser:

image::hello-world-first-view.png[http://localhost:4000]

On the terminal you can see the server log:

[source,bash]
----
[info] GET /
[debug] Processing with DemoWeb.PageController.index/2
  Parameters: %{}
  Pipelines: [:browser]
[info] Sent 200 in 22ms
----

Do a reload in the browser and watch the log output:

[source,bash]
----
[info] GET /
[debug] Processing with DemoWeb.PageController.index/2
  Parameters: %{}
  Pipelines: [:browser]
[info] Sent 200 in 426µs
----

[sidebar] 
The log says that the request was answered in 426µs. WOW!
https://en.wikipedia.org/wiki/Microsecond[Microseconds]! That is on my old
development laptop. That must be the famous speed of Phoenix/Elixir everybody is
talking about.

What we see is the default `index.html.eex` page. The file extension `eex` stands for https://hexdocs.pm/eex/EEx.html[Embedded Elixir] and means that this is a mix of static HTML and dynamic Elixir code which generated HTML. These files are called templates and are located in the `lib/demo_web/templates/` directory. A fresh Phoenix application has two templates:

[source,bash]
----
$ tree lib/demo_web/templates/
lib/demo_web/templates/
├── layout
│   └── app.html.eex
└── page
    └── index.html.eex
----

NOTE: It is no coincedence that the subdirectory is called `demo_web`. Because
we named our application `demo` that name will be used at multiple places.

Let's have a look into `index.html.eex` which contains the core part of the page.

.lib/demo_web/templates/page/index.html.eex
[source,html]
----
<section class="phx-hero">
  <h1><%= gettext "Welcome to %{name}!", name: "Phoenix" %></h1>
  <p>Peace-of-mind from prototype to production</p>
</section>

<section class="row">
  <article class="column">
    <h2>Resources</h2>
    <ul>
      <li>
        <a href="https://hexdocs.pm/phoenix/overview.html">Guides &amp; Docs</a>
      </li>
      <li>
        <a href="https://github.com/phoenixframework/phoenix">Source</a>
      </li>
      <li>
        <a href="https://github.com/phoenixframework/phoenix/blob/v1.5/CHANGELOG.md">v1.5 Changelog</a>
      </li>
    </ul>
  </article>
  <article class="column">
    <h2>Help</h2>
    <ul>
      <li>
        <a href="https://elixirforum.com/c/phoenix-forum">Forum</a>
      </li>
      <li>
        <a href="https://webchat.freenode.net/?channels=elixir-lang">#elixir-lang on Freenode IRC</a>
      </li>
      <li>
        <a href="https://twitter.com/elixirphoenix">Twitter @elixirphoenix</a>
      </li>
      <li>
        <a href="https://elixir-slackin.herokuapp.com/">Elixir on Slack</a>
      </li>
    </ul>
  </article>
</section>
----

But a bit of HTML boilerplate is missing and can be found in `lib/demo_web/templates/layout/app.html.eex`.

.lib/demo_web/templates/layout/app.html.eex
[source,html]
----
<!DOCTYPE html>
<html lang="en"> <1>
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Demo · Phoenix Framework</title> <2>
    <link rel="stylesheet" href="<%= Routes.static_path(@conn, "/css/app.css") %>"/> <3>
    <script defer type="text/javascript" src="<%= Routes.static_path(@conn, "/js/app.js") %>"></script>
  </head>
  <body>
    <header> <4>
      <section class="container">
        <nav role="navigation">
          <ul>
            <li><a href="https://hexdocs.pm/phoenix/overview.html">Get Started</a></li>
            <%= if function_exported?(Routes, :live_dashboard_path, 2) do %>
              <li><%= link "LiveDashboard", to: Routes.live_dashboard_path(@conn, :home) %></li>
            <% end %>
          </ul>
        </nav>
        <a href="https://phoenixframework.org/" class="phx-logo">
          <img src="<%= Routes.static_path(@conn, "/images/phoenix.png") %>" alt="Phoenix Framework Logo"/>
        </a>
      </section>
    </header>
    <main role="main" class="container">
      <p class="alert alert-info" role="alert"><%= get_flash(@conn, :info) %></p> <5>
      <p class="alert alert-danger" role="alert"><%= get_flash(@conn, :error) %></p>
      <%= @inner_content %> <6>
    </main>
  </body>
</html>
----
<1> You might want to change the language here in case this webpage is going to be in an other language than English.
<2> You probably want to change this to a better `<title>`.
<3> Phoenix's asset management takes care of the CSS and JavaScript. No need to worry about it for now.
<4> This is the boilerplate header part you are seeing on the top of every page.
<5> This part renders so called flash messages. We'll get to that later.
<6> This is the line where the template's content gets included.

IMPORTANT: https://hexdocs.pm/eex/EEx.html[Embedded Elixir] (`.eex`) uses the `<% %>` syntax to embedd Elixir code in HTML. `<% %>` runs the Elixir code within. `<%= %>` runs the Elixir code and includes the result of that as HTML in the template.

Feel free to change the content of `app.html.eex` and `index.html.eex` while
having http://localhost:4000 opened in a browser. In development mode each save
of those files triggers a reload of the page in the browser.

## Hello World!

The aim of this section is to create a new dynamic page which is available at
http://localhost:4000/hello and displays the text "Hello World!". We start with
the base setup:

[source,bash]
----
$ mix phx.new demo --no-ecto
[...]
$ cd demo
----

Routes are defined in `lib/demo_web/router.ex`. Let's have a look and add a new
route for our hello world page.

.lib/demo_web/router.ex
[source,elixir]
----
defmodule DemoWeb.Router do
  use DemoWeb, :router

  [...]

  scope "/", DemoWeb do
    pipe_through :browser

    get "/", PageController, :index
    get "/hello", PageController, :hello <1>
  end

  [...]
----
<1> We use the same `PageController` as the `:index` action for our new `:hello` action (function).

Because the route calls the `:hello` action in the `PageController` we have to
add a `hello/2` function in `page_controller.ex`:

.lib/demo_web/controllers/page_controller.ex
[source,elixir]
----
defmodule DemoWeb.PageController do
  use DemoWeb, :controller

  def index(conn, _params) do
    render(conn, "index.html")
  end

  def hello(conn, _params) do <1>
    render(conn, "hello.html")
  end
end
----
<1> The new `hello/2` function renders the `hello.html` template.

Last step: We have to create a template file. Please do so and include this 
source code into it:

.lib/demo_web/templates/page/hello.html.eex
[source,html]
----
<h1>Hello World!</h1>
----

Now open http://localhost:4000/hello in your browser:

image::hello-world.png[http://localhost:4000/hello]

### Hello World with it's own controller

In the last section we added the `:hello` action to the already existing `PageController`. But in many case it makes sense to create a seperate controller. Let's do that so you know how to.

We start with changing the route:

.lib/demo_web/router.ex
[source,elixir]
----
defmodule DemoWeb.Router do
  use DemoWeb, :router

  [...]

  scope "/", DemoWeb do
    pipe_through :browser

    get "/", PageController, :index
    get "/hello", ExampleController, :hello <1>
  end

  [...]
----
<1> Yes, `ExampleController` is not a candiate for best controller name of the year. Good catch!

Let's be lazy and ask Phoenix what to do next. We open http://localhost:4000/hello in the browser:

image::hello-world-examplecontroller-is-undefined.png[http://localhost:4000/hello]

It says `function DemoWeb.ExampleController.init/1 is undefined` which leads us to the next missing piece: A controller. That file needs to be named `example_controller.ex` and is has to be saved in the `lib/demo_web/controllers` directory. Here is the content of it:

.lib/demo_web/controllers/example_controller.ex
[source,elixir]
----
defmodule DemoWeb.ExampleController do <1>
  use DemoWeb, :controller

  def hello(conn, _params) do
    render(conn, "hello.html")
  end
end
----
<1> Important: `DemoWeb.ExampleController`

After a reload we get a new error message: `function DemoWeb.ExampleView.render/2 is undefined`. So we need to create a view file:

.lib/demo_web/views/example_view.ex
[source,elixir]
----
defmodule DemoWeb.ExampleView do <1>
  use DemoWeb, :view
end
----
<1> Important to use the right name here (e.g. 'ExampleView').

A reload and we get our final error message:

image::hello-world-could-not-render-hello-html.png[http://localhost:4000/hello]

The template is missing. But that is an easy fix:

.lib/demo_web/templates/example/hello.html.eex
[source,html]
----
<h1>Hello World!</h1>
----

And here is our good to go webpage:

image::hello-world.png[http://localhost:4000/hello]

#### Checklist for a new page

Everytime you want to create a new action in a new controller you have to take care of these steps:

- Create a route in `lib/demo_web/router.ex`
- Create a controller with the name `lib/demo_web/controllers/example_controller.ex`
- Create an action in that controller which matches the route
- Create a view with the name `lib/demo_web/views/example_view.ex`
- Create a template with the name `lib/demo_web/templates/page/hello.html.eex`

Phoenix will always lead you through the way. If something is missing it will say so in the error message.

WARNING: Obviously `demo_web`, `example_controller.ex`, `example_view.ex` and `hello.html.eex` are just names which fit for our "Hello World!" example. You have to adjust them for your case.

## Use Variables in the Template

