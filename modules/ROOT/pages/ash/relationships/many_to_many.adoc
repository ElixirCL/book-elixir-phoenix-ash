### many_to_many

`many_to_many` is a special case of `has_many` where the relationship is
symmetric. That means that the relationship is defined on both sides of the
relationship. A good example is a `Tag` resource that can be assigned to
multiple (or none) `Product` resources and a `Product` resource has multiple
(or none) `Tag` resources assigned to it.

[source]
----
+------------+     +------------+     +--------+
| Product    |     | ProductTag |     | Tag    |
+------------+     +------------+     +--------+
| product_id |<--->| product_id |     | tag_id |
| Name       |     | tag_id     |<--->| Name   |
| Price      |     |            |     |        |
+------------+     +------------+     +--------+
----

To keep our source code minimal we go back to the
xref:ash/relationships/index.adoc#ash-relationships-setup[relationship setup]
 code which has just the `Product` resource and add a `Tag` and a
 `ProductTag` resource that is the join table between `Tag` and `Product`.

[source,elixir,title='lib/app/shop/resources/tag.ex']
----
defmodule App.Shop.Tag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    many_to_many :products, App.Shop.Product do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :tag_id
      destination_attribute_on_join_resource :product_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :products, {:array, :map}
      change manage_relationship(:products, type: :append_and_remove, on_no_match: :create) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `product`.
<2> This allows us to create a `Tag` resource with a list of `Product` resources
    assigned to it.

[source,elixir,title='lib/app/shop/resources/product_tag.ex']
----
defmodule App.Shop.ProductTag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  actions do
    defaults [:create, :read, :destroy] <1>
  end

  relationships do <2>
    belongs_to :product, App.Shop.Product do
      primary_key? true
      allow_nil? false
    end

    belongs_to :tag, App.Shop.Tag do
      primary_key? true
      allow_nil? false
    end
  end
end
----

<1> No need for an `:update` action. Entries in the join table are immutable. You can delete but not change them.
<2> The clue between the `Product` and the `Tag` resources.

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `tag`.
<2> This allows us to create a `Product` resource with a list of `Tag` resources
    assigned to it.

// TODO: iex Example

[[ash-many_to_many-sideloading]]
#### many_to_many sideloading

[source,elixir,title='lib/app/shop.ex']
----
defmodule App.Shop do
  use Ash.Api

  resources do
    resource App.Shop.Product
    resource App.Shop.ProductTag
    resource App.Shop.Tag
  end
end
----

Let's use it in the `iex` console:

```elixir
$ iex -S mix
Compiling 3 files (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> good_deal = App.Shop.Tag.create!(%{name: "Good deal"}) <1>
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
  name: "Good deal",
  ...
>
iex(2)> yellow = App.Shop.Tag.create!(%{name: "Yellow"}) <2>
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
  name: "Yellow",
  ...
>
iex(3)> App.Shop.Product.create!(%{
            name: "Banana",
            tags: [good_deal, yellow]
            }) <3>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
      name: "Good deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d3551abf-cf43-4c7f-94f1-ea7228d87cf1",
  name: "Banana",
  price: nil,
  ...
>
iex(4)> App.Shop.Product.by_name!("Banana", load: [:tags]) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
      name: "Good deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
      name: "Yellow",
      ...
    >
  ],
  ...
  ],
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d3551abf-cf43-4c7f-94f1-ea7228d87cf1",
  name: "Banana",
  price: nil,
  ...
>
```

<1> Create a tag named "Good deal".
<2> Create a tag named "Yellow".
<3> Create a product named "Banana" and associate it with the two tags.
<4> Retrieve the product by name and sideload its tags.

[[ash-many_to_many-update]]
#### Update many_to_many relationships

Sometimes we want to update the `tags` of a `product` resource.
It feels most natural to do it via the `update` action of the `product` resource.
For that to work we have to define a custom `:update` action that will update the `tags`
relationship. We can more or less copy the code from the `:create` action for that:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do <1>
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Same as the `:create` action.

Let's use it in the `iex` console. We first create a product
with two tags and than we update it to have only one tag:

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Tag
App.Shop.Tag
iex(2)> alias App.Shop.Product
App.Shop.Product
iex(3)> good_deal = Tag.create!(%{name: "Good deal"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
  name: "Good deal",
  ...
>
iex(4)> yellow = Tag.create!(%{name: "Yellow"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
  name: "Yellow",
  ...
>
iex(5)> Product.create!(%{name: "Banana", tags: [yellow, good_deal]}) <1>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
      name: "Good deal",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(6)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <2>
["Yellow", "Good deal"]
iex(7)> banana = Product.by_name!("Banana") <3>
#App.Shop.Product<
  tags: #Ash.NotLoaded<:relationship>,
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(8)> Product.update!(banana, %{tags: [yellow]}) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(9)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <5>
["Yellow"]
```

<1> Create a new product with two tags.
<2> Query the just created product and print the two tag names.
<3> Store the product in the variable `banana` for later use.
<4> Update the product to have only one tag.
<5> Double check that the product really only has one tag.

The between resource `ProductTag` is automatically updated.
And by update I mean that one entry was deleted.

#### Sideload a many_to_many Relationship by Default

This works the same way as the previous `has_many` example:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:destroy] <1>

    read :read do
      primary? true <2>
      prepare build(load: [:tags]) <3>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Don't forget to remove `:read` from the defaults when you add a custom `read` action.
<2> See https://ash-hq.org/docs/guides/ash/latest/topics/actions#primary-actions
<3> Always sideload all `tags` when fetching a `product`.

Let's test it in the iex:

```elixir
iex(15)> App.Shop.Product.by_name!("Banana").tags |> Enum.map(& &1.name)
["Yellow", "Good deal"]
```
