[[ash-many_to_many]]
### many_to_many
indexterm:[Ash, many_to_many]

`many_to_many` is a special case of `has_many` where the relationship is
symmetric. That means that the relationship is defined on both sides of the
relationship. A good example is a `Tag` resource that can be assigned to
multiple (or none) `Product` resources and a `Product` resource has multiple
(or none) `Tag` resources assigned to it.

To keep our source code minimal we go back to the
xref:ash/relationships/index.adoc#ash-relationships-setup[relationship setup]
 code which has just the
`Product` resource and add a `Tag` and a `ProductTag` resource that is
the join table between `Tag` and `Product`.

[source,elixir,title='lib/app/shop/resources/tag.ex']
----
defmodule App.Shop.Tag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    many_to_many :products, App.Shop.Product do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :tag_id
      destination_attribute_on_join_resource :product_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :products, {:array, :map}
      change manage_relationship(:products, type: :append_and_remove, on_no_match: :create) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `product`.
<2> This allows us to create a `Tag` resource with a list of `Product` resources
    assigned to it.

[source,elixir,title='lib/app/shop/resources/product_tag.ex']
----
defmodule App.Shop.ProductTag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  actions do
    defaults [:create, :read, :destroy] <1>
  end

  relationships do <2>
    belongs_to :product, App.Shop.Product do
      primary_key? true
      allow_nil? false
    end

    belongs_to :tag, App.Shop.Tag do
      primary_key? true
      allow_nil? false
    end
  end
end
----

<1> No need for an `:update` action. Entries in the join table are immutable. You can delete but not change them.
<2> The clue between the `Product` and the `Tag` resources.

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `tag`.
<2> This allows us to create a `Product` resource with a list of `Tag` resources
    assigned to it.

// TODO: iex Example

[[ash-many_to_many-sideloading]]
#### many_to_many sideloading

[source,elixir,title='lib/app/shop.ex']
----
defmodule App.Shop do
  use Ash.Api

  resources do
    resource App.Shop.Product
    resource App.Shop.ProductTag
    resource App.Shop.Tag
  end
end
----

Let's use it in the `iex` console:

```elixir
$ iex -S mix
Compiling 3 files (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> good_deal = App.Shop.Tag.create!(%{name: "Good deal"}) <1>
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
  name: "Good deal",
  ...
>
iex(2)> yellow = App.Shop.Tag.create!(%{name: "Yellow"}) <2>
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
  name: "Yellow",
  ...
>
iex(3)> App.Shop.Product.create!(%{
            name: "Banana",
            tags: [good_deal, yellow]
            }) <3>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
      name: "Good deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d3551abf-cf43-4c7f-94f1-ea7228d87cf1",
  name: "Banana",
  price: nil,
  ...
>
iex(4)> App.Shop.Product.by_name!("Banana", load: [:tags]) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
      name: "Good deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
      name: "Yellow",
      ...
    >
  ],
  ...
  ],
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d3551abf-cf43-4c7f-94f1-ea7228d87cf1",
  name: "Banana",
  price: nil,
  ...
>
```

<1> Create a tag named "Good deal".
<2> Create a tag named "Yellow".
<3> Create a product named "Banana" and associate it with the two tags.
<4> Retrieve the product by name and sideload its tags.

[[ash-many_to_many-update]]
#### Update many_to_many relationships

Sometimes we want to update the `tags` of a `product` resource.
It feels most natural to do it via the `update` action of the `product` resource.
For that to work we have to define a custom `:update` action that will update the `tags`
relationship. We can more or less copy the code from the `:create` action for that:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do <1>
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Same as the `:create` action.

Let's use it in the `iex` console. We first create a product
with two tags and than we update it to have only one tag:

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Tag
App.Shop.Tag
iex(2)> alias App.Shop.Product
App.Shop.Product
iex(3)> good_deal = Tag.create!(%{name: "Good deal"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
  name: "Good deal",
  ...
>
iex(4)> yellow = Tag.create!(%{name: "Yellow"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
  name: "Yellow",
  ...
>
iex(5)> Product.create!(%{name: "Banana", tags: [yellow, good_deal]}) <1>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
      name: "Good deal",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(6)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <2>
["Yellow", "Good deal"]
iex(7)> banana = Product.by_name!("Banana") <3>
#App.Shop.Product<
  tags: #Ash.NotLoaded<:relationship>,
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(8)> Product.update!(banana, %{tags: [yellow]}) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(9)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <5>
["Yellow"]
```

<1> Create a new product with two tags.
<2> Query the just created product and print the two tag names.
<3> Store the product in the variable `banana` for later use.
<4> Update the product to have only one tag.
<5> Double check that the product really only has one tag.

The between resource `ProductTag` is automatically updated.
And by update I mean that one entry was deleted.

#### Sideload a many_to_many Relationship by Default

This works the same way as the previous `has_many` example:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:destroy] <1>

    read :read do
      primary? true <2>
      prepare build(load: [:tags]) <3>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Don't forget to remove `:read` from the defaults when you add a custom `read` action.
<2> See https://ash-hq.org/docs/guides/ash/latest/topics/actions#primary-actions
<3> Always sideload all `tags` when fetching a `product`.

Let's test it in the iex:

```elixir
iex(15)> App.Shop.Product.by_name!("Banana").tags |> Enum.map(& &1.name)
["Yellow", "Good deal"]
```

[[ash-managing_relationships]]
### Managing Relationships

In the xref:ash/relationships/has_many.adoc[has_many] and
xref:ash/relationships/many_to_many.adoc[many_to_many]
sections we already saw how to create and update relationships. However
there are additional options available which often make sense to use.
Especially when you want your logic to be portable (e.g. available via
a REST or GraphQL API).

In the xref:ash/relationships/many_to_many.adoc[many_to_many] example with
products and tags we were able to create a product with two tags with
this code:

```elixir
iex> yellow = App.Shop.Tag.create!(%{name: "Yellow"})
iex> good_deal = App.Shop.Tag.create!(%{name: "Good deal"})
iex> App.Shop.Product.create!(%{name: "Banana", tags: [yellow, good_deal]})
```

We have to create the tags first and then pass them to the product.
Wouldn't it be nice to have a `add_tag: %{name: "Yellow"}` argument
available? Guess what!? Ash can help. Let's have a look what needs to
be added at the product resource:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:destroy]

    read :read do
      primary? true
      prepare build(load: [:tags]) <1>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}

      argument :add_tag, :map do
        allow_nil? true <2>
      end

      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
      change manage_relationship(:add_tag, :tags, type: :create)
    end

    update :update do
      primary? true
      argument :tags, {:array, :map}

      argument :add_tag, :map do
        allow_nil? true
      end

      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
      change manage_relationship(:add_tag, :tags, type: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Strictly speaking we do not need the preload here but it makes it a bit easier to debug.
<2> Change that to `true` in case you want to make sure that a tag is always added.

I (we?) don't want to have multiple tags with the same name. So I added a
unique identity to the tag resource:

[source,elixir,title='lib/app/shop/resources/tag.ex']
----
defmodule App.Shop.Tag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  identities do
    # identity :unique_name, [:name] <1>

    identity :name, [:name] do <2>
      pre_check_with App.Shop <3>
    end
  end

  relationships do
    many_to_many :products, App.Shop.Product do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :tag_id
      destination_attribute_on_join_resource :product_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :products, {:array, :map}

      change manage_relationship(:products,
               type: :append_and_remove,
               on_no_match: :create,
               use_identities: [:unique_name]
             )
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Use this if you use a PostgreSQL database.
<2> Use this if your use a ETS data layer like we do in this example.
<3> Since ETS doesn't support unique indexes we have to check for uniqueness before we create it.

```elixir
$ iex -S mix
iex(1)> banana = App.Shop.Product.create!(%{name: "Banana", add_tag: %{name: "Yellow"}}) <1>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "747d1802-8269-4b0f-b7f8-e2b66098334e",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "ce306c71-c928-43a8-b6c2-e6bd28a50408",
  name: "Banana",
  price: nil,
  ...
>
iex(2)> App.Shop.Product.update!(banana, %{add_tag: %{name: "Good Deal"}}) <2>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "69dc7da7-5533-4f51-aded-dd64da292b1b",
      name: "Good Deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "a6d4949a-c985-480e-94a0-0507934a2cb6",
      name: "Good Deal",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "6e70a0d4-6a26-4edc-8e54-813690522dbc",
  name: "Banana",
  price: nil,
  ...
>
iex(3)> App.Shop.Product.update!(banana, %{add_tag: %{name: "Yellow"}}) <3>
** (Ash.Error.Invalid) Input Invalid

* name: has already been taken
    at add_tag
[...]
iex(3)> App.Shop.Product.update(banana, %{add_tag: %{name: "Yellow"}}) <4>
{:error,
 %Ash.Error.Invalid{
   errors: [
     %Ash.Error.Changes.InvalidChanges{
       fields: [:name],
       message: "has already been taken",
       validation: nil,
       value: nil,
       changeset: nil,
       query: nil,
       error_context: [],
       vars: [],
       path: [:add_tag],
       stacktrace: #Stacktrace<>,
       class: :invalid
     }
   ],
[...]
```

<1> Create a new product with a tag.
<2> Add a new tag to the product.
<3> Try to add a tag with the same name as the first tag. This fails.
<4> Same uniqueness check but this time we don't raise an error but return an error tuple.
