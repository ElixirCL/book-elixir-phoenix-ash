### many_to_many

`many_to_many` is a special case of `has_many` where the relationship is
symmetric. That means that the relationship is defined on both sides of the
relationship. A good example is a `Tag` resource that can be assigned to
multiple (or none) `Product` resources and a `Product` resource has multiple
(or none) `Tag` resources assigned to it.

[source]
----
+---------+     +------------+     +--------+
| Product |     | ProductTag |     | Tag    |
+---------+     +------------+     +--------+
| id      |<--->| product_id |     | name   |
| name    |     | tag_id     |<--->| id     |
| price   |     |            |     |        |
+---------+     +------------+     +--------+
----

To keep our source code footprint minimal we use the
xref:ash/relationships/index.adoc#ash-relationships-setup[relationship setup]
 example code which has just the `Product` resource and add a `Tag` and a
 `ProductTag` resource that is the join table between `Tag` and `Product`.

[source,elixir,title='lib/app/shop/resources/tag.ex']
----
defmodule App.Shop.Tag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    many_to_many :products, App.Shop.Product do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :tag_id
      destination_attribute_on_join_resource :product_id
    end <1>
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :products, {:array, :map}

      change manage_relationship(:products,
               type: :append_and_remove,
               on_no_match: :create
             ) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `product`.
<2> This allows us to create a `Tag` resource with a list of `Product` resources
    assigned to it.

[source,elixir,title='lib/app/shop/resources/product_tag.ex']
----
defmodule App.Shop.ProductTag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  actions do
    defaults [:create, :read, :destroy] <1>
  end

  relationships do <2>
    belongs_to :product, App.Shop.Product do
      primary_key? true
      allow_nil? false
    end

    belongs_to :tag, App.Shop.Tag do
      primary_key? true
      allow_nil? false
    end
  end
end
----

<1> No need for an `:update` action. Entries in the join table are immutable. You can delete but not change them.
<2> The clue between the `Product` and the `Tag` resources.

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}

      change manage_relationship(:tags,
               type: :append_and_remove,
               on_no_match: :create
             ) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `tag`.
<2> This allows us to create a `Product` resource with a list of `Tag` resources
    assigned to it.

#### Example Usage in iex

Let's use the following data for our example.

NOTE: Ash does use UUIDs. I use integer IDs in the example
table because it's easier to read for humans.

[source]
----
Product:
+----+--------+
| id | name   |
+----+--------+
| 1  | Apple  |
| 2  | Banana |
| 3  | Cherry |
+----+--------+

Tag:
+----+---------+
| id | Name    |
+----+---------+
| 1  | Sweet   |
| 2  | Tropical|
| 3  | Red     |
+----+---------+

ProductTag:
+-----------+-------+
| product_id| tag_id|
+-----------+-------+
| 1         | 1     |  (Apple is Sweet)
| 1         | 3     |  (Apple is Red)
| 2         | 1     |  (Banana is Sweet)
| 2         | 2     |  (Banana is Tropical)
| 3         | 3     |  (Cherry is Red) <1>
+-----------+-------+
----

<1> Not a complete list of all real world combinations.
I am aware that cherries can be sweet too. ðŸ˜‰

Open the iex and create all the products with their tags.

```elixir
$ iex -S mix
iex(1)> alias App.Shop.Tag
iex(2)> alias App.Shop.Product
iex(3)> sweet = Tag.create!(%{name: "Sweet"})
iex(4)> tropical = Tag.create!(%{name: "Tropical"})
iex(5)> red = Tag.create!(%{name: "Red"})
iex(6)> Product.create!(%{name: "Apple", tags: [sweet, red]})
iex(7)> Product.create!(%{name: "Banana", tags: [sweet, tropical]})
iex(8)> Product.create!(%{name: "Cherry", tags: [red]})
```

Now we can read all products with their tags and vice versa.

```elixir
iex(9)> Product.read!(load: [:tags]) |>
...(9)> Enum.map(fn product ->
...(9)>   %{
...(9)>     product_name: product.name,
...(9)>     tag_names: Enum.map(product.tags, & &1.name)
...(9)>   }
...(9)> end)
[
  %{product_name: "Banana", tag_names: ["Sweet", "Tropical"]},
  %{product_name: "Apple", tag_names: ["Sweet", "Red"]},
  %{product_name: "Cherry", tag_names: ["Red"]}
]

iex(10)> Tag.read!(load: [:products]) |>
...(10)> Enum.map(fn tag ->
...(10)>   %{
...(10)>     tag_name: tag.name,
...(10)>     product_names: Enum.map(tag.products, & &1.name)
...(10)>   }
...(10)> end)
[
  %{tag_name: "Tropical", product_names: ["Banana"]},
  %{tag_name: "Red", product_names: ["Cherry", "Apple"]},
  %{tag_name: "Sweet", product_names: ["Apple", "Banana"]}
]
```

[[ash-many_to_many-sideloading]]
#### many_to_many sideloading

Be default Ash will not load the join table entries. You can change this with the
`:load` option in the `:read` action:

[source,elixir,title='lib/app/product.ex']
----
  # [...]

  actions do
    defaults [:update, :destroy] <1>

    read :read do
      primary? true
      prepare build(load: [:tags]) <2>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}

      change manage_relationship(:tags,
               type: :append_and_remove,
               on_no_match: :create
             )
    end
  end

  # [...]
----

<1> Don't forget to remove `:read` here.
<2> Always sideload the `tags` relationship.

[source,elixir,title='lib/app/product.ex']
----
  # [...]

  actions do
    defaults [:update, :destroy] <1>

    read :read do
      primary? true
      prepare build(load: [:products]) <2>
    end

    create :create do
      primary? true
      argument :products, {:array, :map}

      change manage_relationship(:products,
               type: :append_and_remove,
               on_no_match: :create
             )
    end
  end

  # [...]
----

<1> Don't forget to remove `:read` here.
<2> Always sideload the `products` relationship.

Let's use it in the `iex` console:

```elixir
$ iex -S mix
iex(1)> alias App.Shop.Tag
iex(2)> alias App.Shop.Product
iex(3)> sweet = Tag.create!(%{name: "Sweet"})
iex(4)> tropical = Tag.create!(%{name: "Tropical"})
iex(5)> red = Tag.create!(%{name: "Red"})
iex(6)> Product.create!(%{name: "Apple", tags: [sweet, red]})
iex(7)> Product.create!(%{name: "Banana", tags: [sweet, tropical]})
iex(8)> Product.create!(%{name: "Cherry", tags: [red]})

iex(9)> Product.read! |> <1>
...(9)> Enum.map(fn product ->
...(9)>   %{
...(9)>     product_name: product.name,
...(9)>     tag_names: Enum.map(product.tags, & &1.name)
...(9)>   }
...(9)> end)
[
  %{product_name: "Banana", tag_names: ["Sweet", "Tropical"]},
  %{product_name: "Apple", tag_names: ["Sweet", "Red"]},
  %{product_name: "Cherry", tag_names: ["Red"]}
]

iex(10)> Tag.read! |> <2>
...(10)> Enum.map(fn tag ->
...(10)>   %{
...(10)>     tag_name: tag.name,
...(10)>     product_names: Enum.map(tag.products, & &1.name)
...(10)>   }
...(10)> end)
[
  %{tag_name: "Tropical", product_names: ["Banana"]},
  %{tag_name: "Red", product_names: ["Cherry", "Apple"]},
  %{tag_name: "Sweet", product_names: ["Apple", "Banana"]}
]
```

<1> We don't have to specify `load: [:tags]` here because we set it as the default in the `:read` action.
<2> We don't have to specify `load: [:tags]` here because we set it as the default in the `:read` action.

[[ash-many_to_many-update]]
#### Update many_to_many relationships

Sometimes we want to update the `tags` of a `product` resource.
It feels most natural to do it via the `update` action of the `product` resource.
For that to work we have to define a custom `:update` action that will update the `tags`
relationship. We can more or less copy the code from the `:create` action for that:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do <1>
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Same as the `:create` action.

Let's use it in the `iex` console. We first create a product
with two tags and than we update it to have only one tag:

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Tag
App.Shop.Tag
iex(2)> alias App.Shop.Product
App.Shop.Product
iex(3)> good_deal = Tag.create!(%{name: "Good deal"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
  name: "Good deal",
  ...
>
iex(4)> yellow = Tag.create!(%{name: "Yellow"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
  name: "Yellow",
  ...
>
iex(5)> Product.create!(%{name: "Banana", tags: [yellow, good_deal]}) <1>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
      name: "Good deal",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(6)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <2>
["Yellow", "Good deal"]
iex(7)> banana = Product.by_name!("Banana") <3>
#App.Shop.Product<
  tags: #Ash.NotLoaded<:relationship>,
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(8)> Product.update!(banana, %{tags: [yellow]}) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(9)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <5>
["Yellow"]
```

<1> Create a new product with two tags.
<2> Query the just created product and print the two tag names.
<3> Store the product in the variable `banana` for later use.
<4> Update the product to have only one tag.
<5> Double check that the product really only has one tag.

The between resource `ProductTag` is automatically updated.
And by update I mean that one entry was deleted.

#### Sideload a many_to_many Relationship by Default

This works the same way as the previous `has_many` example:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:destroy] <1>

    read :read do
      primary? true <2>
      prepare build(load: [:tags]) <3>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Don't forget to remove `:read` from the defaults when you add a custom `read` action.
<2> See https://ash-hq.org/docs/guides/ash/latest/topics/actions#primary-actions
<3> Always sideload all `tags` when fetching a `product`.

Let's test it in the iex:

```elixir
iex(15)> App.Shop.Product.by_name!("Banana").tags |> Enum.map(& &1.name)
["Yellow", "Good deal"]
```
