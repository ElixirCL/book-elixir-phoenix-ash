[[resource]]
## Resource

Resources are the cornerstones of any Ash application. We use them to
model our data and define actions which are used to manipulate the
data.

NOTE: In the Ash world the resources are often compared with nouns and
the actions with verbs.

## A To-Do-List Application

To dive into resources we use a simple to-do-list application as an
example. Please use the
<<minimal-ash-2x-setup-guide, Minimal Ash 2.x Setup Guide>> to generate
a new Elixir application.

We want to create a `task` resource which has a `content` attribute
and an `id` attribute as a primary key. We also want to include the
actions `create`, `read`, `update` and `delete`. Ash provides those
actions but we have to include them into the resource.

In the Ash world a resource needs to be registered via a registry to an
interal API. Don't think of this as an external WebAPI. Ash uses the
term API for an internal interface. We call our API `ToDoList`.

### Configure the API

We have to add the new API to the `:ash_apis` in our `config.exs` file.

[source,elixir,title='config/config.exs']
----
import Config

config :ash, :use_all_identities_in_manage_relationship?, false
config :app, :ash_apis, [App.ToDoList] # Add this line
----

Now we create the API module which contains the registry.

[source,elixir,title='lib/app/to_do_list.ex']
----
defmodule App.ToDoList do
  use Ash.Api

  resources do
    registry App.ToDoList.Registry
  end
end
----

For the resource itself we create a new directory:

```bash
$ mkdir -p lib/app/to_do_list/resources
```

Now we have to create the registry for our resources.

[source,elixir,title='lib/app/to_do_list/registry.ex']
----
defmodule App.ToDoList.Registry do
  use Ash.Registry

  entries do
    entry App.ToDoList.Task
  end
end
----

### Configure the Resource

After we have created the API we can create the resource.

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :content, :string
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end
end
----

IMPORTANT: In this example we use the
link:https://hexdocs.pm/ash/Ash.DataLayer.Ets.html[Ash.DataLayer.Ets] as
a database layer. ETS (Erlang Term Storage) is an in memory data store
which is build into your Erlang system. For our training purpose this
is ideal because we don't have to install and configure a database (e.g.
PostgreSQL). **But ETS does not save any data to disk!** With every
restart of these examples you will have to re-create the data.

The resulting directory structure should look like this:

```bash
$ tree lib
lib
├── app
│   ├── application.ex
│   ├── to_do_list
│   │   ├── registry.ex
│   │   └── resources
│   │       └── task.ex
│   └── to_do_list.ex
└── app.ex

4 directories, 5 files
```

### Create a Resource

Fire up the IEx (Elixir’s Interactive Shell) to play around with our new application.

```bash
$ iex -S mix
Erlang/OTP 26 [erts-14.0.2] [...]

Interactive Elixir (1.15.5) [...]
iex(1)>
```

NOTE: For those who jumped into this chapter without any prior knowledge
of Elixir: You can stop the `iex` shell with `Ctrl+C` twice.

We can create a new task by using the `Ash.Changeset.for_create/3`
function and call the `App.ToDoList.create!/1` function with that changeset:

```elixir
iex(1)> App.ToDoList.Task
App.ToDoList.Task
iex(2)> |> Ash.Changeset.for_create(:create, %{content: "Mow the lawn"})
#Ash.Changeset<
  action_type: :create,
  action: :create,
  attributes: %{content: "Mow the lawn"},
  relationships: %{},
  errors: [],
  data: #App.ToDoList.Task<
    __meta__: #Ecto.Schema.Metadata<:built, "">,
    id: nil,
    content: nil,
    aggregates: %{},
    calculations: %{},
    ...
  >,
  valid?: true
>
iex(3)> |> App.ToDoList.create!()
#App.ToDoList.Task<
  __meta__: #Ecto.Schema.Metadata<:built, "">,
  id: "2aface85-0e7b-4b4c-885b-22405ff612ab",
  content: "Mow the lawn",
  aggregates: %{},
  calculations: %{},
  ...
>
```

### Code Interface

Doing a `App.ToDoList.Task |> Ash.Changeset.for_create(:create,
%{content: "Mow the lawn"}) |> App.ToDoList.create!()` can feel a bit
cumbersome and Ash is all about making things more productive for
the developer. Let's add a `code_interface` section to the `task`
resource for some Ash magic which creates a
`App.ToDoList.Task.create!/1` function so that we can use
`App.ToDoList.Task.create!(%{content: "Mow the lawn"})` to create a
new task.

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :content, :string
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.ToDoList
    define :create
  end
end
----

After restarting the `iex` we can now create a new `task` much
easier:

```elixir
$ iex -S mix
Compiling 2 files (.ex)
Erlang/OTP 26 [erts-14.0.2] [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.create!(%{content: "Mow the lawn"})
#App.ToDoList.Task<
  __meta__: #Ecto.Schema.Metadata<:built, "">,
  id: "8e868c09-c0d0-4362-8270-09272acab769",
  content: "Mow the lawn",
  aggregates: %{},
  calculations: %{},
  ...
>
iex(2)>
```

The function `App.ToDoList.Task.create!/1` raises an error if
something goes wrong (e.g. a validation error). Alternatively you can
use `App.ToDoList.Task.create/1` which returns a tuple with the status
and the resource.

```elixir
iex(2)> App.ToDoList.Task.create(%{content: "Mow the lawn"})
{:ok,
 #App.ToDoList.Task<
   __meta__: #Ecto.Schema.Metadata<:built, "">,
   id: "a8430505-ef7e-4f64-bc2c-2a6db216d8ea",
   content: "Mow the lawn",
   aggregates: %{},
   calculations: %{},
   ...
 >}
iex(3)>
```

### Validations

Validation of user input is a key for a smooth running application.
Otherwise we end up with faulty datasets in our database. For our
example we will add one validation for `content` to make sure that
content will always have a length between 1 and 255 characters. And we
add a second attribute `priority` which is an integer and has to be
either `nil` or between 1 and 3.

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id

    attribute :content, :string do
      allow_nil? false
      constraints min_length: 1, max_length: 255
    end

    attribute :priority, :integer do
      allow_nil? true
      constraints min: 1, max: 3
    end
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.ToDoList
    define :create
  end
end
----

Let's try to create a new task with no content. I use `Task.create!/1`
and `Task.create/1` to show the different output of each function.

```elixir
$ iex -S mix
Compiling 2 files (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.create()
{:error,
 %Ash.Error.Invalid{
   errors: [
     %Ash.Error.Changes.Required{
       field: :content,
       type: :attribute,
       resource: App.ToDoList.Task,
       changeset: nil,
       query: nil,
       error_context: [],
       vars: [],
       path: [],
       stacktrace: #Stacktrace<>,
       class: :invalid
     }
   ],
   stacktraces?: true,
   changeset: #Ash.Changeset<
     api: App.ToDoList,
     action_type: :create,
     action: :create,
     attributes: %{},
     relationships: %{},
     errors: [
       %Ash.Error.Changes.Required{
         field: :content,
         type: :attribute,
         resource: App.ToDoList.Task,
         changeset: nil,
         query: nil,
         error_context: [],
         vars: [],
         path: [],
         stacktrace: #Stacktrace<>,
         class: :invalid
       }
     ],
     data: #App.ToDoList.Task<
       __meta__: #Ecto.Schema.Metadata<:built, "">,
       id: nil,
       content: nil,
       priority: nil,
       aggregates: %{},
       calculations: %{},
       ...
     >,
     valid?: false
   >,
   query: nil,
   error_context: [nil],
   vars: [],
   path: [],
   stacktrace: #Stacktrace<>,
   class: :invalid
 }}
iex(2)> App.ToDoList.Task.create!()
** (Ash.Error.Invalid) Input Invalid

* attribute content is required
    (ash 2.14.16) lib/ash/api/api.ex:2169: Ash.Api.unwrap_or_raise!/3
iex(2)>
```

Now let's see what happens when we try to create a task with a valid
`content` but with a `priority` which is not between 1 and 3.

```elixir
iex(2)> App.ToDoList.Task.create!(%{content: "Mown the lawn", priority: 10})
** (Ash.Error.Invalid) Input Invalid

* Invalid value provided for priority: must be less than or equal to 3.

10

    (ash 2.14.16) lib/ash/api/api.ex:2169: Ash.Api.unwrap_or_raise!/3
iex(3)>
```

### Defaults

Attributes can have default values. Let's add a `is_done` boolean
attribute with a default of `false` and a validation that doesn't allow
`nil` for this attribute:

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id

    attribute :content, :string do
      allow_nil? false
      constraints min_length: 1, max_length: 255
    end

    attribute :priority, :integer do
      allow_nil? true
      constraints min: 1, max: 3
    end

    attribute :is_done, :boolean do
      allow_nil? false
      default false
    end
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.ToDoList
    define :create
  end
end
----

Now we can create a new task without providing a value for `is_done`:

[source,elixir]
----
iex> App.ToDoList.Task.create(%{content: "Mown the lawn"})
{:ok,
 #App.ToDoList.Task<
   __meta__: #Ecto.Schema.Metadata<:built, "">,
   id: "07d5b3f1-b960-4390-8980-5e731251d7af",
   content: "Mown the lawn",
   priority: nil,
   is_done: false,
   aggregates: %{},
   calculations: %{},
   ...
 >}
----

### default_accept

Sometimes a resource as an attribute which we don't want to have
writeble for the user. Ash provides a functionality for this. Within
the `actions` we can use `default_accept` to define a whitelist of
accepted attributes.

In our example application we want to allow the user to create and
update the `content` and `priority` attributes but not the `is_done`
attribute.

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  # ...

  actions do
    default_accept [:content, :priority] # add this line
    defaults [:create, :read, :update, :destroy]
  end

  # ...
end
----

Should a user try to change the `id_done` attribute in a create or
update the system will not accept it. See the `"cannot be changed"`
message:

```elixir
$ iex -S mix
Compiling 2 files (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.create(%{content: "Mow the lawn", is_done: true})
{:error,
 %Ash.Error.Invalid{
   errors: [
     %Ash.Error.Changes.InvalidAttribute{
       field: :is_done,
       message: "cannot be changed",
       private_vars: nil,
       value: true,
       changeset: nil,
       query: nil,
       error_context: [],
       vars: [],
       path: [],
       stacktrace: #Stacktrace<>,
       class: :invalid
     }
   ],
   stacktraces?: true,
   changeset: #Ash.Changeset<
     api: App.ToDoList,
     action_type: :create,
     action: :create,
     attributes: %{content: "Mow the lawn", is_done: true},
     relationships: %{},
     errors: [
       %Ash.Error.Changes.InvalidAttribute{
         field: :is_done,
         message: "cannot be changed",
         private_vars: nil,
         value: true,
         changeset: nil,
         query: nil,
         error_context: [],
         vars: [],
         path: [],
         stacktrace: #Stacktrace<>,
         class: :invalid
       }
     ],
     data: #App.ToDoList.Task<
       __meta__: #Ecto.Schema.Metadata<:built, "">,
       id: nil,
       content: nil,
       priority: nil,
       is_done: nil,
       aggregates: %{},
       calculations: %{},
       ...
     >,
     valid?: false
   >,
   query: nil,
   error_context: [nil],
   vars: [],
   path: [],
   stacktrace: #Stacktrace<>,
   class: :invalid
 }}
iex(2)>
```

### Read

Writing is one thing but it only makes sense if you can read the written
data too. To make our life a bit easier we add a `code_interface`
section for `read`:

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  # ...

  code_interface do
    define_for App.ToDoList
    define :create
    define :read # add this line
  end
end
----

#### Index

To fetch a list of all tasks in the database we can use the
`App.ToDoList.Task.read!/1` (results in a list) or
`App.ToDoList.Task.read/1` (results in a tuple with a status and a
list) functions. Those are automatically generated by Ash by the
`code_interface` part of the `task` resource.

```elixir
$ iex -S mix
Compiling 2 files (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.create!(%{content: "Mow the lawn"})
#App.ToDoList.Task<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "881c6c08-223c-41b1-9d61-2d3a40e478bd",
  content: "Mow the lawn",
  ...
>
iex(2)> App.ToDoList.Task.create!(%{content: "Buy milk"})
#App.ToDoList.Task<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "22b11587-20fe-40d2-830e-50f8930c13c9",
  content: "Buy milk",
  ...
>
iex(3)> App.ToDoList.Task.read!
[
  #App.ToDoList.Task<
    __meta__: #Ecto.Schema.Metadata<:loaded>,
    id: "22b11587-20fe-40d2-830e-50f8930c13c9",
    content: "Buy milk",
    ...
  >,
  #App.ToDoList.Task<
    __meta__: #Ecto.Schema.Metadata<:loaded>,
    id: "881c6c08-223c-41b1-9d61-2d3a40e478bd",
    content: "Mow the lawn",
    ...
  >
]
iex(4)> App.ToDoList.Task.read
{:ok,
 [
   #App.ToDoList.Task<
     __meta__: #Ecto.Schema.Metadata<:loaded>,
     id: "22b11587-20fe-40d2-830e-50f8930c13c9",
     content: "Buy milk",
     ...
   >,
   #App.ToDoList.Task<
     __meta__: #Ecto.Schema.Metadata<:loaded>,
     id: "881c6c08-223c-41b1-9d61-2d3a40e478bd",
     content: "Mow the lawn",
     ...
   >
 ]}
iex(5)>
```

If you have an empty database this is your result for both functions:

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.read!
[]
iex(2)> App.ToDoList.Task.read
{:ok, []}
iex(3)>
```

#### Show

Often one wants to fetch a specific set of data by an `id`. The Ash
`code_interface` has an easy solution for us:

[source,elixir,title='lib/app/to_do_list/resources/task.ex']
----
defmodule App.ToDoList.Task do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  # ...

  code_interface do
    define_for App.ToDoList
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read # add this line
  end
end
----

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.read!
[]
iex(2)> App.ToDoList.Task.read
{:ok, []}
iex(3)> task = App.ToDoList.Task.create!(%{content: "Mow the lawn"})
#App.ToDoList.Task<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "4c9a01c9-8be1-422a-ba55-6426e9c6811c",
  content: "Mow the lawn",
  ...
>
iex(4)> task.id
"4c9a01c9-8be1-422a-ba55-6426e9c6811c"
iex(5)> App.ToDoList.Task.by_id!("4c9a01c9-8be1-422a-ba55-6426e9c6811c")
#App.ToDoList.Task<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "4c9a01c9-8be1-422a-ba55-6426e9c6811c",
  content: "Mow the lawn",
  ...
>
iex(6)> App.ToDoList.Task.by_id("4c9a01c9-8be1-422a-ba55-6426e9c6811c")
{:ok,
 #App.ToDoList.Task<
   __meta__: #Ecto.Schema.Metadata<:loaded>,
   id: "4c9a01c9-8be1-422a-ba55-6426e9c6811c",
   content: "Mow the lawn",
   ...
 >}
iex(7)>
```

And here an example when there is no task in the database for the
given `id`:

[source,elixir]
----
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> App.ToDoList.Task.by_id!("not-in-the-db")
** (Ash.Error.Query.NotFound) record not found
    (app 0.1.0) deps/ash/lib/ash/code_interface.ex:518: App.ToDoList.Task.by_id!/3
iex(1)> App.ToDoList.Task.by_id("not-in-the-db")
{:error,
 %Ash.Error.Query.NotFound{
   primary_key: nil,
   resource: App.ToDoList.Task,
   changeset: nil,
   query: nil,
   error_context: [],
   vars: [],
   path: [],
   stacktrace: #Stacktrace<>,
   class: :invalid
 }}
iex(2)>
----
