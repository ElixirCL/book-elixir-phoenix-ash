[[ash-relationships]]
## Relationships
indexterm:[Ash, Relationships]

Relationships define connections between resources. In any application this
is the bread and butter of the data modeling.

[[ash-relationships-setup]]
### Setup

We discuss relationships in the context of a simple online shop. Please
use xref:ash/minimal-ash-2x-setup-guide.adoc[Minimal Ash 2.x Setup Guide] to generate
a new Elixir application. After that include or adapt the following files for a
`Product` resource:

[source,elixir,title='config/config.exs']
----
import Config

config :ash, :use_all_identities_in_manage_relationship?, false
config :app, :ash_apis, [App.Shop]
----

[source,elixir,title='lib/app/shop.ex']
----
defmodule App.Shop do
  use Ash.Api

  resources do
    resource App.Shop.Product
  end
end
----

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

[[ash-belongs_to]]
### belongs_to
indexterm:[Ash, belongs_to]

The `belongs_to` macro defines a relationship between two resources.

[TIP]
====
Do you like video tutorials? Have a look at
"belongs_to in 2 minutes" in our
https://www.youtube.com/@elixir-phoenix-ash[@elixir-phoenix-ash YouTube Channel].

video::lP8YtkXD3RE[youtube,width=640,height=360]
====

In our shop example, a `Product` belongs to a `Category`.
For that to work we need a new `Category` resource:

[source,elixir,title='lib/app/shop/resources/category.ex']
----
defmodule App.Shop.Category do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

And we need to add it to the internal API:

[source,elixir,title='lib/app/shop.ex']
----
defmodule App.Shop do
  use Ash.Api

  resources do
    resource App.Shop.Product
    resource App.Shop.Category
  end
end
----

To configure the `belongs_to` relationship to `Category` we add one
line to the `Product` resource:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do <1>
    belongs_to :category, App.Shop.Category do <2>
      attribute_writable? true <3>
    end
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The `relationships` macro defines relationships between resources.
<2> The source_attribute is defined as :<relationship_name>_id of
the type :uuid on the source resource and the destination_attribute
is assumed to be :id. To override those defaults have a look at
https://hexdocs.pm/ash/relationships.html and https://ash-hq.org/docs/dsl/ash-resource#relationships-belongs_to
<3> By default the attribute `category_id` is not writable (see https://ash-hq.org/docs/dsl/ash-resource#relationships-belongs_to-attribute_writable-).
To make it writable we need to set `attribute_writable?` to `true`. Only than we can create a `Product` with a `Category` in on call.

```elixir
$ iex -S mix
Compiling 3 files (.ex)
Generated app app
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Product <1>
App.Shop.Product
iex(2)> alias App.Shop.Category
App.Shop.Category
iex(3)> fruits = Category.create!(%{name: "Fruits"}) <2>
#App.Shop.Category<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
  name: "Fruits",
  ...
>
iex(4)> orange = Product.create!(%{
                   name: "Orange",
                   price: 0.15,
                   category_id: fruits.id
                 }) <3>
#App.Shop.Product<
  category: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "6870b44b-67ed-4186-97ed-bbfffd1fc2a0",
  name: "Orange",
  price: Decimal.new("0.15"),
  category_id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
  ...
>
iex(5)> App.Shop.load(orange, :category) <4>
{:ok,
 #App.Shop.Product<
   category: #App.Shop.Category<
     __meta__: #Ecto.Schema.Metadata<:loaded>,
     id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
     name: "Fruits",
     ...
   >,
   __meta__: #Ecto.Schema.Metadata<:loaded>,
   id: "6870b44b-67ed-4186-97ed-bbfffd1fc2a0",
   name: "Orange",
   price: Decimal.new("0.15"),
   category_id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
   ...
 >}
iex(6)> orange2 = Product.by_name!("Orange", load: [:category])
#App.Shop.Product<
  category: #App.Shop.Category<
    __meta__: #Ecto.Schema.Metadata<:loaded>,
    id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
    name: "Fruits",
    ...
  >,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "6870b44b-67ed-4186-97ed-bbfffd1fc2a0",
  name: "Orange",
  price: Decimal.new("0.15"),
  category_id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
  ...
>
iex(7)> orange2.category
#App.Shop.Category<
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "91cb42d8-45c2-451d-8261-72ae4d94a3c6",
  name: "Fruits",
  ...
>
iex(8)> orange2.category.name
"Fruits"
```

<1> Let's save a bit of typing by creating shorter Aliases.
<2> Create a new `Category` for "Fruits" and store it in the variable `fruits`.
<3> Create a new `Product` for "Orange" which belongs to the `Category` "Fruits" and store it in the variable `orange`.
<4> One way to get the `Category` of a `Product` if that wasn't sideloaded initially.
<5> Sideload the `Category` of the `Product` when fetching The `Product from the database.

#### Sideload a belongs_to Relationship by Default

In case you always want to sideload the `Category` of the `Product` without adding
`load: [:category]` to every call you can do the following:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    belongs_to :category, App.Shop.Category do
      attribute_writable? true
    end
  end

  actions do
    defaults [:create, :update, :destroy] <1>

    read :read do
      primary? true <2>
      prepare build(load: [:category]) <3>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Don't forget to remove `:read` from the defaults when you add a custom `read` action.
<2> See https://ash-hq.org/docs/guides/ash/latest/topics/actions#primary-actions
<3> Always sideload the `Category` when fetching a `Product`.

Let's test it in the iex:

```elixir
iex(9)> Product.by_name("Orange")
{:ok,
 #App.Shop.Product<
   category: #App.Shop.Category<
     __meta__: #Ecto.Schema.Metadata<:loaded>,
     id: "22ab0824-18ac-4daa-9a13-defd0b8bcd73",
     name: "Fruits",
     ...
   >,
   __meta__: #Ecto.Schema.Metadata<:loaded>,
   id: "24348935-6148-4c75-9bf1-55f74ac9397a",
   name: "Orange",
   price: Decimal.new("0.15"),
   category_id: "22ab0824-18ac-4daa-9a13-defd0b8bcd73",
   ...
 >}
```

[[ash-has_many]]
### has_many
indexterm:[Ash, has_many]

`has_many` is the oposite site of a `belongs_to` relationship. In our shop example a `Category` has many `Products`.

[TIP]
====
Do you like video tutorials? Have a look at
"has_many in 2m 19s" in our
https://www.youtube.com/@elixir-phoenix-ash[@elixir-phoenix-ash YouTube Channel].

video::jQZGHl4B4fU[youtube,width=640,height=360]
====

Using the <<ash-belongs_to, belongs_to>> example and setup we can now add a
`has_many` relationship to the `Category` resource:

[source,elixir,title='lib/app/shop/resources/category.ex']
----
defmodule App.Shop.Category do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    has_many :products, App.Shop.Product <1>
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The `has_many` macro defines a relationship between two resources. In our
example, a `Category` has many `Products`. For that to work we need a
`Product` resource. By default, the source_attribute is assumed to be `:id`
and destination_attribute defaults to <snake_cased_last_part_of_module_name>_id.
To override those defaults have a look at
https://hexdocs.pm/ash/relationships.html and https://ash-hq.org/docs/dsl/ash-resource#relationships-has_many

Let's play with the new relationship:

```elixir
$ iex -S mix
Compiling 1 file (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Product
App.Shop.Product
iex(2)> alias App.Shop.Category
App.Shop.Category
iex(3)> fruits = Category.create!(%{name: "Fruits"}) <1>
#App.Shop.Category<
  products: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
  name: "Fruits",
  ...
>
iex(4)> Product.create!(%{name: "Orange", category_id: fruits.id}) <2>
#App.Shop.Product<
  category: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "3ec1c834-70a8-403d-8814-3070c77b525e",
  name: "Orange",
  price: nil,
  category_id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
  ...
>
iex(5)> Product.create!(%{name: "Banana", category_id: fruits.id})
#App.Shop.Product<
  category: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "460d8cfa-2dad-4da0-95db-45012aa33621",
  name: "Banana",
  price: nil,
  category_id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
  ...
>
iex(6)> App.Shop.load(fruits, :products) <3>
{:ok,
 #App.Shop.Category<
   products: [
     #App.Shop.Product<
       category: #Ash.NotLoaded<:relationship>,
       __meta__: #Ecto.Schema.Metadata<:loaded>,
       id: "3ec1c834-70a8-403d-8814-3070c77b525e",
       name: "Orange",
       price: nil,
       category_id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
       ...
     >,
     #App.Shop.Product<
       category: #Ash.NotLoaded<:relationship>,
       __meta__: #Ecto.Schema.Metadata<:loaded>,
       id: "460d8cfa-2dad-4da0-95db-45012aa33621",
       name: "Banana",
       price: nil,
       category_id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
       ...
     >
   ],
   __meta__: #Ecto.Schema.Metadata<:loaded>,
   id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
   name: "Fruits",
   aggregates: %{},
   calculations: %{},
   ...
 >}
iex(7)> Category.by_name!("Fruits", load: [:products]) <4>
#App.Shop.Category<
  products: [
    #App.Shop.Product<
      category: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "3ec1c834-70a8-403d-8814-3070c77b525e",
      name: "Orange",
      price: nil,
      category_id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
      ...
    >,
    #App.Shop.Product<
      category: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "460d8cfa-2dad-4da0-95db-45012aa33621",
      name: "Banana",
      price: nil,
      category_id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
      ...
    >
  ],
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c77919cf-0a28-4394-96f1-28f70f1d748a",
  name: "Fruits",
  ...
>
```

<1> Create a category for fruits.
<2> Create two products and assign them to the fruits category.
<3> Load the products for the fruits category.
<4> Sideload all the products for the fruits category.

#### Sideload a has_many Relationship by Default

In case you always want to sideload all `products` of a `category` without
adding `load: [:category]` to every call you can do the following:

[source,elixir,title='lib/app/shop/resources/category.ex']
----
defmodule App.Shop.Category do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    has_many :products, App.Shop.Product
  end

  actions do
    defaults [:create, :update, :destroy] <1>

    read :read do
      primary? true <2>
      prepare build(load: [:products]) <3>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Don't forget to remove `:read` from the defaults when you add a custom `read` action.
<2> See https://ash-hq.org/docs/guides/ash/latest/topics/actions#primary-actions
<3> Always sideload all `products` when fetching a `Category`.

Let's test it in the iex:

```elixir
iex(17)> Category.by_name!("Fruits").products |> Enum.map(& &1.name)
["Orange", "Banana"]
```

[[ash-has_one]]
### has_one
indexterm:[Ash, has_one]

NOTE: I do not know if I ever used `has_one` in a real world application. But
for the sake of completeness, I pull out an example out of thin air for this.

`has_one` is similar to `belongs_to` except that the reference attribute is
on the destination resource, instead of the source.

Let's assume we run special promotions in our shop (so and so many percent
rebate off). But each product can only have one promotion and each promotion
can only be used for one product. I know! It is just an example for `has_one`.

[source,elixir,title='lib/app/shop.ex']
----
defmodule App.Shop do
  use Ash.Api

  resources do
    resource App.Shop.Product
    resource App.Shop.Category
    resource App.Shop.Promotion
  end
end
----

[source,elixir,title='lib/app/shop/resources/promotion.ex']
----
defmodule App.Shop.Promotion do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :rebate, :integer
    attribute :product_id, :uuid
  end

  relationships do
    belongs_to :product, App.Shop.Product do
      attribute_writable? true
    end
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    belongs_to :category, App.Shop.Category do
      attribute_writable? true
    end

    has_one :promotion, App.Shop.Promotion
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

Let's use it in the `iex` console:

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Product
App.Shop.Product
iex(2)> alias App.Shop.Promotion
App.Shop.Promotion
iex(3)> orange = Product.create!(%{name: "Orange", price: 0.2})
#App.Shop.Product<
  promotion: #Ash.NotLoaded<:relationship>,
  category: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c9e9b4ba-408f-4c42-b1e0-e8b3799d5b1f",
  name: "Orange",
  price: Decimal.new("0.2"),
  category_id: nil,
  ...
>
iex(4)> {:ok, promotion} = Promotion.create(%{name: "15% off", rebate: 15, product_id: orange.id})
{:ok,
 #App.Shop.Promotion<
   product: #Ash.NotLoaded<:relationship>,
   __meta__: #Ecto.Schema.Metadata<:loaded>,
   id: "68901cef-f2c5-46bb-a737-d6c248d36347",
   name: "15% off",
   rebate: 15,
   product_id: "c9e9b4ba-408f-4c42-b1e0-e8b3799d5b1f",
   ...
 >}
iex(5)> App.Shop.load(orange, :promotion) <1>
{:ok,
 #App.Shop.Product<
   promotion: #App.Shop.Promotion<
     product: #Ash.NotLoaded<:relationship>,
     __meta__: #Ecto.Schema.Metadata<:loaded>,
     id: "68901cef-f2c5-46bb-a737-d6c248d36347",
     name: "15% off",
     rebate: 15,
     product_id: "c9e9b4ba-408f-4c42-b1e0-e8b3799d5b1f",
     ...
   >,
   category: #Ash.NotLoaded<:relationship>,
   __meta__: #Ecto.Schema.Metadata<:loaded>,
   id: "c9e9b4ba-408f-4c42-b1e0-e8b3799d5b1f",
   name: "Orange",
   price: Decimal.new("0.2"),
   category_id: nil,
   ...
 >}
```

<1> By default the promotion is not sideloaded. We have to load it manually.
<2> This is the way to sideload the promotion relationship.

[[ash-many_to_many]]
### many_to_many
indexterm:[Ash, many_to_many]

`many_to_many` is a special case of `has_many` where the relationship is
symmetric. That means that the relationship is defined on both sides of the
relationship. A good example is a `Tag` resource that can be assigned to
multiple (or none) `Product` resources and a `Product` resource has multiple
(or none) `Tag` resources assigned to it.

To keep our source code minimal we go back to the
<<ash-relationships-setup, relationship setup>> code which has just the
`Product` resource and add a `Tag` and a `ProductTag` resource that is
the join table between `Tag` and `Product`.

[source,elixir,title='lib/app/shop/resources/tag.ex']
----
defmodule App.Shop.Tag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    many_to_many :products, App.Shop.Product do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :tag_id
      destination_attribute_on_join_resource :product_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :products, {:array, :map}
      change manage_relationship(:products, type: :append_and_remove, on_no_match: :create) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `product`.
<2> This allows us to create a `Tag` resource with a list of `Product` resources
    assigned to it.

[source,elixir,title='lib/app/shop/resources/product_tag.ex']
----
defmodule App.Shop.ProductTag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  actions do
    defaults [:create, :read, :destroy] <1>
  end

  relationships do <2>
    belongs_to :product, App.Shop.Product do
      primary_key? true
      allow_nil? false
    end

    belongs_to :tag, App.Shop.Tag do
      primary_key? true
      allow_nil? false
    end
  end
end
----

<1> No need for an `:update` action. Entries in the join table are immutable. You can delete but not change them.
<2> The clue between the `Product` and the `Tag` resources.

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do <1>
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create) <2>
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> The configuration for the `many_to_many` relationship to `tag`.
<2> This allows us to create a `Product` resource with a list of `Tag` resources
    assigned to it.

# TODO: iex Example

[[ash-many_to_many-sideloading]]

[source,elixir,title='lib/app/shop.ex']
----
defmodule App.Shop do
  use Ash.Api

  resources do
    resource App.Shop.Product
    resource App.Shop.ProductTag
    resource App.Shop.Tag
  end
end
----

Let's use it in the `iex` console:

```elixir
$ iex -S mix
Compiling 3 files (.ex)
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> good_deal = App.Shop.Tag.create!(%{name: "Good deal"}) <1>
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
  name: "Good deal",
  ...
>
iex(2)> yellow = App.Shop.Tag.create!(%{name: "Yellow"}) <2>
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
  name: "Yellow",
  ...
>
iex(3)> App.Shop.Product.create!(%{
            name: "Banana",
            tags: [good_deal, yellow]
            }) <3>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
      name: "Good deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d3551abf-cf43-4c7f-94f1-ea7228d87cf1",
  name: "Banana",
  price: nil,
  ...
>
iex(4)> App.Shop.Product.by_name!("Banana", load: [:tags]) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "82b7e8af-69b9-4f35-b32a-0b6b2bed1d15",
      name: "Good deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "d04aa5ef-195e-4dd8-9c5a-5c73e6f44afe",
      name: "Yellow",
      ...
    >
  ],
  ...
  ],
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "d3551abf-cf43-4c7f-94f1-ea7228d87cf1",
  name: "Banana",
  price: nil,
  ...
>
```

<1> Create a tag named "Good deal".
<2> Create a tag named "Yellow".
<3> Create a product named "Banana" and associate it with the two tags.
<4> Retrieve the product by name and sideload its tags.

[[ash-many_to_many-update]]
#### Update many_to_many relationships

Sometimes we want to update the `tags` of a `product` resource.
It feels most natural to do it via the `update` action of the `product` resource.
For that to work we have to define a custom `:update` action that will update the `tags`
relationship. We can more or less copy the code from the `:create` action for that:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do <1>
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Same as the `:create` action.

Let's use it in the `iex` console. We first create a product
with two tags and than we update it to have only one tag:

```elixir
$ iex -S mix
Erlang/OTP 26 [...]

Interactive Elixir (1.15.5) [...]
iex(1)> alias App.Shop.Tag
App.Shop.Tag
iex(2)> alias App.Shop.Product
App.Shop.Product
iex(3)> good_deal = Tag.create!(%{name: "Good deal"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
  name: "Good deal",
  ...
>
iex(4)> yellow = Tag.create!(%{name: "Yellow"})
#App.Shop.Tag<
  products: #Ash.NotLoaded<:relationship>,
  products_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
  name: "Yellow",
  ...
>
iex(5)> Product.create!(%{name: "Banana", tags: [yellow, good_deal]}) <1>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "34603537-c96d-4dbc-a8bb-e22489c3e5ea",
      name: "Good deal",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(6)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <2>
["Yellow", "Good deal"]
iex(7)> banana = Product.by_name!("Banana") <3>
#App.Shop.Product<
  tags: #Ash.NotLoaded<:relationship>,
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(8)> Product.update!(banana, %{tags: [yellow]}) <4>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "1ad4b16c-77ac-4d6d-8b7a-e40348f651f0",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "c885b447-4bcd-4d05-8a2f-f3b1cfde4949",
  name: "Banana",
  price: nil,
  ...
>
iex(9)> Product.by_name!("Banana", load: [:tags]).tags |> Enum.map(& &1.name) <5>
["Yellow"]
```

<1> Create a new product with two tags.
<2> Query the just created product and print the two tag names.
<3> Store the product in the variable `banana` for later use.
<4> Update the product to have only one tag.
<5> Double check that the product really only has one tag.

The between resource `ProductTag` is automatically updated.
And by update I mean that one entry was deleted.

#### Sideload a many_to_many Relationship by Default

This works the same way as the previous `has_many` example:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:destroy] <1>

    read :read do
      primary? true <2>
      prepare build(load: [:tags]) <3>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end

    update :update do
      primary? true
      argument :tags, {:array, :map}
      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Don't forget to remove `:read` from the defaults when you add a custom `read` action.
<2> See https://ash-hq.org/docs/guides/ash/latest/topics/actions#primary-actions
<3> Always sideload all `tags` when fetching a `product`.

Let's test it in the iex:

```elixir
iex(15)> App.Shop.Product.by_name!("Banana").tags |> Enum.map(& &1.name)
["Yellow", "Good deal"]
```

[[ash-managing_relationships]]
### Managing Relationships

In the <<ash-has_many, has_many>> and <<ash-many_to_many, many_to_many>>
sections we already saw how to create and update relationships. However
there are additional options available which often make sense to use.
Especially when you want your logic to be portable (e.g. available via
a REST or GraphQL API).

In the <<ash-many_to_many, many_to_many>> example with products and tags
we were able to create a product with two tags with this code:

```elixir
iex> yellow = App.Shop.Tag.create!(%{name: "Yellow"})
iex> good_deal = App.Shop.Tag.create!(%{name: "Good deal"})
iex> App.Shop.Product.create!(%{name: "Banana", tags: [yellow, good_deal]})
```

We have to create the tags first and then pass them to the product.
Wouldn't it be nice to have a `add_tag: %{name: "Yellow"}` argument
available? Guess what!? Ash can help. Let's have a look what needs to
be added at the product resource:

[source,elixir,title='lib/app/shop/resources/product.ex']
----
defmodule App.Shop.Product do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
    attribute :price, :decimal
  end

  relationships do
    many_to_many :tags, App.Shop.Tag do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :product_id
      destination_attribute_on_join_resource :tag_id
    end
  end

  actions do
    defaults [:destroy]

    read :read do
      primary? true
      prepare build(load: [:tags]) <1>
    end

    create :create do
      primary? true
      argument :tags, {:array, :map}

      argument :add_tag, :map do
        allow_nil? true <2>
      end

      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
      change manage_relationship(:add_tag, :tags, type: :create)
    end

    update :update do
      primary? true
      argument :tags, {:array, :map}

      argument :add_tag, :map do
        allow_nil? true
      end

      change manage_relationship(:tags, type: :append_and_remove, on_no_match: :create)
      change manage_relationship(:add_tag, :tags, type: :create)
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Strictly speaking we do not need the preload here but it makes it a bit easier to debug.
<2> Change that to `true` in case you want to make sure that a tag is always added.

I (we?) don't want to have multiple tags with the same name. So I added a
unique identity to the tag resource:

[source,elixir,title='lib/app/shop/resources/tag.ex']
----
defmodule App.Shop.Tag do
  use Ash.Resource, data_layer: Ash.DataLayer.Ets

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  identities do
    # identity :unique_name, [:name] <1>

    identity :name, [:name] do <2>
      pre_check_with App.Shop <3>
    end
  end

  relationships do
    many_to_many :products, App.Shop.Product do
      through App.Shop.ProductTag
      source_attribute_on_join_resource :tag_id
      destination_attribute_on_join_resource :product_id
    end
  end

  actions do
    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      argument :products, {:array, :map}

      change manage_relationship(:products,
               type: :append_and_remove,
               on_no_match: :create,
               use_identities: [:unique_name]
             )
    end
  end

  code_interface do
    define_for App.Shop
    define :create
    define :read
    define :by_id, get_by: [:id], action: :read
    define :by_name, get_by: [:name], action: :read
    define :update
    define :destroy
  end
end
----

<1> Use this if you use a PostgreSQL database.
<2> Use this if your use a ETS data layer like we do in this example.
<3> Since ETS doesn't support unique indexes we have to check for uniqueness before we create it.

```elixir
$ iex -S mix
iex(1)> banana = App.Shop.Product.create!(%{name: "Banana", add_tag: %{name: "Yellow"}}) <1>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "747d1802-8269-4b0f-b7f8-e2b66098334e",
      name: "Yellow",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "ce306c71-c928-43a8-b6c2-e6bd28a50408",
  name: "Banana",
  price: nil,
  ...
>
iex(2)> App.Shop.Product.update!(banana, %{add_tag: %{name: "Good Deal"}}) <2>
#App.Shop.Product<
  tags: [
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "69dc7da7-5533-4f51-aded-dd64da292b1b",
      name: "Good Deal",
      ...
    >,
    #App.Shop.Tag<
      products: #Ash.NotLoaded<:relationship>,
      products_join_assoc: #Ash.NotLoaded<:relationship>,
      __meta__: #Ecto.Schema.Metadata<:loaded>,
      id: "a6d4949a-c985-480e-94a0-0507934a2cb6",
      name: "Good Deal",
      ...
    >
  ],
  tags_join_assoc: #Ash.NotLoaded<:relationship>,
  __meta__: #Ecto.Schema.Metadata<:loaded>,
  id: "6e70a0d4-6a26-4edc-8e54-813690522dbc",
  name: "Banana",
  price: nil,
  ...
>
iex(3)> App.Shop.Product.update!(banana, %{add_tag: %{name: "Yellow"}}) <3>
** (Ash.Error.Invalid) Input Invalid

* name: has already been taken
    at add_tag
[...]
iex(3)> App.Shop.Product.update(banana, %{add_tag: %{name: "Yellow"}}) <4>
{:error,
 %Ash.Error.Invalid{
   errors: [
     %Ash.Error.Changes.InvalidChanges{
       fields: [:name],
       message: "has already been taken",
       validation: nil,
       value: nil,
       changeset: nil,
       query: nil,
       error_context: [],
       vars: [],
       path: [:add_tag],
       stacktrace: #Stacktrace<>,
       class: :invalid
     }
   ],
[...]
```

<1> Create a new product with a tag.
<2> Add a new tag to the product.
<3> Try to add a tag with the same name as the first tag. This fails.
<4> Same uniqueness check but this time we don't raise an error but return an error tuple.
