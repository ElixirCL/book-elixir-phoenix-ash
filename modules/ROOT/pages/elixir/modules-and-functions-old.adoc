== Modules and Functions
indexterm:["Modules", "Functions"]

To build an application, we need to piece together the elements we have learned
so fare in a structured manner. This is where modules and functions step in.

Elixir organizes code into modules, which essentially are containers for 
functions. 

[source,elixir]
----
iex> defmodule Store do <1>
...>   def total_price(price, amount) do <2>
...>     price * amount <3>
...>   end
...> end
{:module, Store,
 <<...>>, {:total_price, 2}} <4>
iex> Store.total_price(10,7) <5>
70
----
<1> The `defmodule` keyword defines a module. A module name always starts with 
a capital letter.
<2> The `def` keyword defines a function within a module.
<3> The value of the final expression in a function is its return value.
<4> The output you see here is the return value of the module creation.
<5> This syntax allows you to call a function of a module from outside that 
module.

IMPORTANT: `defmodule` and `def` employ a `do ... end` construct to mark 
beginning and end.

NOTE: Module names use `CamelCase` and start with a capital letter, while 
function names adopt the `snake_case`.

Let's save the following module to `math.exs` as an example:

[source,elixir, :file: math.exs]
----
defmodule Math do
  def sum(x, y) do
    x + y
  end

  def difference(x, y) do
    x - y
  end
end
----

To access the functions in the `Math` module in the `iex`, we need to load and compile it with `c("math.exs")`.

[source,elixir]
----
$ iex
Erlang/OTP 26 [erts-14.0] [source] [64-bit] [...]

Interactive Elixir (1.15.0-rc.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> c("math.exs")
[Math]
iex(2)> Math.sum(1, 2)
3
iex(3)> Math.difference(30, 1)
29
iex(4)>
----

=== Private Functions
indexterm:["Private Functions"]

There may be times when you wish to encapsulate certain functionalities within 
a module, making them inaccessible from outside. Elixir facilitates this 
through private functions, declared using the `defp` keyword:

[source,elixir]
----
iex> defmodule Area do
...>   def circle(radius) do
...>     pi() * radius * radius
...>   end
...>
...>   defp pi do <1>
...>     3.14
...>   end
...> end

iex> Area.circle(10) <2>
314.0
iex> Area.pi <3>
** (UndefinedFunctionError) function Area.pi/0 is undefined or private
    Area.pi()
----
<1> `pi/0` is a private function, only accessible within its module.
<2> `circle/1` is public and can be invoked externally. It can access `pi/0`, 
since both functions belong to the same module.
<3> Being private, `pi/0` cannot be accessed from outside its module, hence 
the `UndefinedFunctionError`.

Private functions are excellent for hiding implementation details and reducing 
the exposed interface of a module. They foster modular design by ensuring 
that each function only does one thing and that the module only exposes what's 
necessary for other parts of your application to function.

Consider `defp` as a tool to maintain clean, organized code. It aids in 
readability and comprehension, making it easier for others (or future you) 
to understand your code. Just remember, private functions cannot be tested 
directly, so use them judiciously. Testable public functions should handle 
most of the application logic, while private functions are more for internal 
organization of the module.

[[function-arity]]
=== Function Arity
indexterm:["Function Arity", "Arity"]

Arity refers to the number of arguments a function accepts. In Elixir, a
function is identified by its name and its arity, denoted as `name/arity`. This
concept is foundational in Elixir because it allows multiple functions with the
same name but different arities in a single module. These are essentially
distinct functions because of their varying argument count.

A quick glance at the `Rectangle` module below exemplifies this idea:

[source,elixir]
----
iex> defmodule Rectangle do
...>   def area(side) do
...>     area(side, side)
...>   end
...>
...>   def area(length, breadth) do
...>     length * breadth
...>   end
...> end

iex> Rectangle.area(3)
9
iex> Rectangle.area(4, 5)
20
----
The `area/1` function accepts one parameter and calculates the area of a square.
In contrast, the `area/2` function accepts two parameters and computes the area
of a rectangle. They share the same function name `area` but are considered
different functions due to their distinct arities.

The arity feature boosts code flexibility by allowing you to define multiple
functions that perform similar but distinct tasks under the same name.

[[hierarchical-modules]]
=== Hierarchical Modules
indexterm:["Hierarchical Modules"]

Organizing your code into a structured and manageable form becomes increasingly
important as your project grows. In Elixir, you can achieve this using
hierarchical module names. These hierarchical modules are defined by appending
sub-module names to the parent module using a `.` delimiter.

[source,elixir]
----
iex> defmodule Calculator.Area do
...>   def square(side) do
...>     side * side
...>   end
...> end

iex> Calculator.Area.square(5)
25
----
This `.` notation provides a convenient shorthand for defining nested modules.
The equivalent way of expressing this hierarchy using nested module definition
would be:

[source,elixir]
----
iex> defmodule Calculator do
...>   defmodule Area do
...>     def square(side) do
...>       side * side
...>     end
...>   end
...> end

iex> Calculator.Area.square(5)
25
----
In both instances, we achieve the same outcome. The choice between the two 
methods depends on your project's structure and your personal style preference.
These hierarchical modules provide a clear path for code organization, 
simplifying navigation and readability in large codebases.

[[import-modules]]
=== Import
indexterm:["Import", "Import Modules"]

Elixir provides the `import` directive for accessing public functions from other modules without needing to use their fully qualified names.

Consider this `Rectangle` module with two area calculation functions:

[source,elixir]
----
iex> defmodule Rectangle do
...>   def area(side) do
...>     side * side
...>   end
...>
...>   def area(length, width) do
...>     length * width
...>   end
...> end
----
By using `import`, you can call these functions directly without prefixing them with the module name:

[source,elixir]
----
iex> import Rectangle <1>
Rectangle
iex> area(5) <2>
25
----
<1> The `import Rectangle` directive allows direct access to all the functions of the `Rectangle` module.
<2> Now, you can call `area/1` directly without needing to specify `Rectangle.` beforehand.

You can also limit your import to specific functions from the module:

[source,elixir]
----
iex> import Rectangle, only: [area: 2] <1>
Rectangle
iex> area(1) <2>
** (CompileError) iex:7: undefined function area/1

iex> area(1,5) <3>
5
----
<1> This line imports only the `area/2` function from the `Rectangle` module, excluding other functions.
<2> An attempt to use `area/1` results in a compile error since it wasn't imported.
<3> The `area/2` function works as expected.

NOTE: If you are using a function without a preceding module name, it's most likely because its module has been imported already. Elixir automatically imports certain modules such as the `Kernel` module.

[[import-hierarchical-modules]]
=== Importing Hierarchical Modules
indexterm:["Import Hierarchical Modules"]

When working with hierarchical modules, you may often find the need to import
them for ease of use. Let's consider the `Calculator.Area` module:

[source,elixir]
----
iex> defmodule Calculator.Area do
...>   def square(a) do
...>     a * a
...>   end
...> end

iex> import Calculator.Area
Calculator.Area
iex> square(5)
25
----

[[alias-modules]]
=== Alias
indexterm:["Alias"]

The `alias` directive allows you to assign a shorter, alternative name to a
module, enhancing readability and maintainability of your code.

Consider the `Calculator.Area` module from before:

[source,elixir]
----
iex> defmodule Calculator.Area do
...>   def square(a) do
...>     a * a
...>   end
...> end

iex> alias Calculator.Area, as: Area <1>
Calculator.Area
iex> Area.square(99)
9801
----
<1> Here we've set an alias for `Calculator.Area` as `Area`.

Elixir also allows you to use a shortcut when the alias name is the last part of
the module name:

[source,elixir]
----
iex> alias Calculator.Area <1>
Calculator.Area
iex> Area.square(99)
9801
----
<1> This command sets an alias `Area` for `Calculator.Area` using a more concise syntax.

[[use-keyword]]
=== The 'use' Keyword
indexterm:["Use"]

In Elixir, `use` is a special keyword that helps to keep our code DRY (Don't
Repeat Yourself) and organized. When you include `use ModuleName` in your code,
you're essentially instructing Elixir to take certain actions defined in
`ModuleName` and execute them right within the current module.

For example, suppose you have the following scenario:

[source,elixir]
----
defmodule Math do
  defmacro __using__(_) do
    quote do
      def add(a, b), do: a + b
    end
  end
end

defmodule Calc do
  use Math
end
----

Here, `Calc` module *uses* the `Math` module. The `use` keyword triggers the
`__using__` macro in the `Math` module, which in turn injects the `add` function
definition into the `Calc` module. Therefore, we can call `add` function
directly on the `Calc` module:

[source,elixir]
----
iex> Calc.add(1, 2)
3
----

NOTE: If you're working with a Phoenix application, you might see `use
ExUnit.Case` in your test files. This is a practical example where `ExUnit.Case`
provides a set of functionalities (like assert functions) that will be
accessible within your test cases.

