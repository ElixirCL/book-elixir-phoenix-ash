### Keyword List, Map and Struct
indexterm:["Structured Data Types", "Keyword Lists, Maps and Structs"]

While Lists and Tuples are useful, they lack the ability to access values using a specific key. This is where more advanced data types like Keyword Lists, Maps, and Structs come into play, providing key-value pair functionality.



#### Map
indexterm:["Map"]

Maps are data structures that store key-value pairs and are created using the `%{}` syntax.

[source,elixir]
----
iex> product_prices = %{"Apple" => 0.5, "Orange" => 0.7} <1>
%{"Apple" => 0.5, "Orange" => 0.7}
iex> product_prices["Orange"] <2>
0.7
iex> product_prices["Banana"] <3>
nil
iex> product_prices = %{"Apple" => 0.5, "Orange" => 0.7, "Apple" => 1}
warning: key "Apple" will be overridden in map
  iex:4

%{"Apple" => 1, "Orange" => 0.7} <4>
----
<1> A new map is created and bound to the variable `product_prices`.
<2> Value retrieval is straightforward: append the key to the map name within brackets.
<3> If the given key

 doesn't exist, it returns `nil`.
<4> Unlike keyword lists, maps disallow duplicate keys.

Maps are flexible, allowing any data type to serve as both keys and values:

[source,elixir]
----
iex> %{"one" => 1, "two" => "abc", 3 => 7, true => "asdf"} <1>
%{3 => 7, true => "asdf", "one" => 1, "two" => "abc"}
iex> %{"one" => 1, true => "asdf", true => "z"} <2>
warning: key true will be overridden in map
  iex:2

%{true => "z", "one" => 1}
----
<1> Feel free to mix and match different types of keys and values.
<2> Each key must be unique within a map. If there are duplicates, the last one overwrites the previous values. In this case, the key `true` now maps to the value "z".

##### Atom Key

Maps support atom keys, enabling some handy features:

[source,elixir]
----
iex> product_prices = %{apple: 0.5, orange: 0.7} <1>
%{apple: 0.5, orange: 0.7}
iex> product_prices.apple <2>
0.5
iex> product_prices.banana <3>
** (KeyError) key :banana not found in: %{apple: 0.5, orange: 0.7}
----
<1> This syntax makes reading and typing easier when using atoms as keys.
<2> Atom keys allow the use of the dot operator (`.`) to access their values.
<3> If an attempt is made to access a nonexistent key with the dot operator, an error is thrown.

##### Map Functions
indexterm:["Map Functions"]

The `Map` module of Elixir provides many useful functions for working with maps:

[source,elixir]
----
iex> product_prices = %{apple: 0.5, orange: 0.7, coconut: 1}
%{apple: 0.5, coconut: 1, orange: 0.7}
iex> Map.to_list(product_prices) <1>
[apple: 0.5, coconut: 1, orange: 0.7]
iex> Map.values(product_prices) <2>
[0.5, 1, 0.7]
iex> Map.split(product_prices, [:orange, :apple]) <3>
{%{apple: 0.5, orange: 0.7}, %{coconut: 1}}
iex> a = Map.delete(product_prices, :orange) <4>
%{apple: 0.5, coconut: 1}
iex> b = Map.drop(product_prices, [:apple, :orange]) <5>
%{coconut: 1}
iex> additional_prices = %{banana: 0.4, pineapple: 1.2}
%{banana: 0.4, pineapple: 1.2}
iex> Map.merge(product_prices, additional_prices) <6>
%{apple: 0.5, banana: 0.4, coconut: 1, orange: 0.7, pineapple: 1.2}
iex> c = Map.put(product_prices, :potato, 0.2) <7>
%{apple: 0.5, coconut: 1, orange: 0.7, potato: 0.2}
----
<1> `Map.to_list/1`

 converts a map into a keyword list.
<2> `Map.values/1` retrieves all the values from a map.
<3> `Map.split/2` divides a map into two new maps based on the provided key list (e.g., `[:orange, :apple]`).
<4> `Map.delete/2` removes a key-value pair from a map.
<5> `Map.drop/2` removes multiple key-value pairs specified by a list from a map.
<6> `Map.merge/2` combines two maps.
<7> `Map.put/2` adds a new key-value pair to a map.

#### Struct
indexterm:["Structs"]

A struct is a map variant that includes compile-time checks and default values. The `defstruct` construct is used to define a struct:

[source,elixir]
----
iex> defmodule Product do <1>
...>   defstruct name: nil, price: 0 <2>
...> end

iex> %Product{}
%Product{name: nil, price: 0}
iex> apple = %Product{name: "Apple", price: 0.5} <3>
%Product{name: "Apple", price: 0.5}
iex> apple
%Product{name: "Apple", price: 0.5}
iex> apple.price
0.5
iex> orange = %Product{name: "Orange"} <4>
%Product{name: "Orange", price: 0}
----
<1> Here we define a new struct named `Product` with the keys `name` and `price`.
<2> Default values are set for the keys.
<3> A new `Product` struct is created, setting values for all keys.
<4> A new `Product` struct is created with only the name set, leaving the price at its default value.

Structs ensure that only defined fields can be accessed:

[source,elixir]
----
iex> apple.description <1>
** (KeyError) key :description not found in: %Product{name: "Apple", price: 0.5}

iex> banana = %Product{name: "Banana", weight: 0.1} <2>
** (KeyError) key :weight not found
    expanding struct: Product.__struct__/1
    iex:7: (file)
iex>
----
<1> Accessing an undefined field, like `description` in the `Product` struct, will result in an error.
<2> Similarly, trying to set an undefined field, such as `weight`, while creating a new struct will also cause an error.

NOTE: As structs are built on top of maps, all map functions are applicable to them.