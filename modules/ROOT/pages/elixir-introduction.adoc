

## Higher-Order Functions

In Elixir, functions can be used like any other variable. For example, they can
be passed to other functions as parameters.

A function that takes another function as one of its parameters is called a
higher-order function, and these are very commonly used in Elixir.

When passing a function to a higher-order function, we need to use an anonymous
function, and that is what we will look at next.

### Anonymous Functions
indexterm:["Functions", "Anonymous Functions"]

Anonymous functions are functions that are defined without any name.

You define anonymous functions using the `fn` keyword:

[source,elixir]
----
iex> greeting = fn(name) -> "Hello #{name}!" end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex> greeting.("Bob") <2>
"Hello Bob!"
iex> greeting.("Alice")
"Hello Alice!"
iex> square_area = fn a -> a * a end <3>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex> square_area.(10)
100
iex> area = fn width, length -> width * length end <4>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex> area.(2,8)
16
----
<1> We create an anonymous function and bind it to the variable `greeting`.
* `fn` tells Elixir that you want to define a function.
* `name` is a parameter we can use to inject values.
* `->` is the operator to indicate the following expression is the body of the function.
* `end` indicates the end of the function.
<2> We need to use the `.` (dot) operator to run anonymous functions.
<3> You don't have to surround the function arguments with parentheses. They
are optional.
<4> Like regular functions, anonymous functions can be called with multiple
arguments. The arguments are separated by commas.

Most of the time anonymous functions are simple one liners. 
But they can contain multiple lines of code too:

[source,elixir]
----
iex> circular_area = fn radius ->
...>   pi = 3.14159265359
...>   pi * radius * radius
...> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex> circular_area.(3)
28.274333882310003
----

Let's see how we can use anonymous functions within higher-order functions:

[source,elixir]
----
iex> numbers = [1,2,3,4,5,6,7,8,9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
iex> Enum.filter(numbers, fn num -> rem(num, 2) == 0 end) <1>
[2, 4, 6, 8]
iex> Enum.map(numbers, fn x -> x * x end) <2>
[1, 4, 9, 16, 25, 36, 49, 64, 81]
----
<1> `Enum.filter/2` filters a list and returns those elements for which the
function returns true. The `rem/2` function calculates the remainder after
integer division.
<2> `Enum.map/2` calls the given function for every item in the list and returns a
new list.

### The & operator
indexterm:["& operator", "Capture operator", "Capture syntax"]

Another - and sometimes easier to work with - way of creating anonymous functions 
is to use the `&` operator, which is called the *capture operator*. Have 
a look at this example:

[source,elixir]
----
iex> second = &Enum.at(&1, 1) <1>
#Function<44.97283095/1 in :erl_eval.expr/5>
iex> second.([1,2,3,4]) <2>
2
iex> is_negative? = &(&1 < 0)
#Function<44.97283095/1 in :erl_eval.expr/5>
iex> is_negative?.(-1)
true
----
<1> `&1` refers to the first parameter.
<2> Again, we need to use the `.` (dot) operator to run anonymous functions.

And here are examples of using the capture operator with higher-order functions.

[source,elixir]
----
iex> maybe_numbers = [1, nil, 4, nil, 5]
[1, nil, 4, nil, 5]
iex> Enum.filter(maybe_numbers, &is_integer(&1)) <1>
[1, 4, 5]
iex> Enum.filter(maybe_numbers, &is_integer/1) <2>
[1, 4, 5]
iex> Enum.sort([1, 2, 3], &(&1 >= &2)) <3>
[3, 2, 1]
----
<1> `&1` refers to the first parameter.
<2> The same as the previous function, but with a different syntax. The `/1`
after `is_integer` means that the function takes one parameter.
<3> You can use multiple parameters too (e.g. `&1`, `&2`).

WARNING: Sometimes it is more convenient to use the `&` operator, but there are times
when it makes the expression more difficult to read.

### Variable Scopes
indexterm:["Scopes", "Variable Scopes"]

In every programming language variables have some sort of scope. Let's have a
look into some code to figure out how variables in Elixir are scoped:

[source,elixir]
----
iex> area = 5 <1>
5
iex> IO.puts(area)
5
:ok
iex> square_area = fn a -> <2>
...>   area = a * a <3>
...>   area
...> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex> square_area.(10) <4>
100
iex> IO.puts(area) <5>
5
:ok
----
<1> We bind the value of 5 to the variable `area`.
<2> We define an anonymous function.
<3> Within this function we bind the result of our calculation to another variable `area`.
<4> Run the function with an argument of 10. That would mean that the `area` in the function gets set to the value 100.
<5> The original `area` hasn't changed a bit. Because it is in a different scope.

The `area` within the function is in an inner scope. The original `area` is in an outer scope.

But it gets a bit more complex:

[source,elixir]
----
iex> pi = 3.14159265359 <1>
3.14159265359
iex> circular_area = fn radius -> pi * radius * radius end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex> circular_area.(10)
314.15926535899996
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We create an anonymous function which uses the variable `pi` to make the calculation.

So we can read the outer scope variable from within the function. So lets check
if we can change it too:

[source,elixir]
----
iex> pi = 3.14159265359 <1>
3.14159265359
iex> circular_area = fn radius ->
...>   pi = 3.14 <2>
...>   pi * radius * radius
...> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex> circular_area.(10) <3>
314.0
iex> IO.puts(pi) <4>
3.14159265359
:ok
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We bind the inner scoped variable `pi` with the value 3.14.
<3> The 3.14 and not the 3.14159265359 gets used.
<4> The outer scoped `pi` is not changed.

IMPORTANT: You can not change the value of an outer scoped variable, but you can read
it. And you can create a new inner scope variable with the same name without
interacting with the outer scoped one.



## Pattern Matching
indexterm:["Pattern Matching"]

Pattern matching is essential in Elixir, and we have already used it, without
knowing it, for binding values to variables.

[source,elixir]
----
iex> a = 10 <1>
10
iex> a
10
iex> {b, c} = {10, 15} <2>
{10, 15}
iex> b
10
iex> c
15
iex> {d, e} = 100
** (MatchError) no match of right hand side value: 100 <3>
----
<1> This is actually a pattern match. The left side of `=` will be matched to the right site if possible.
<2> Here we pattern match `{b, c}` on the left side with a tuple on the right side.
<3> Boom! Because we can not match the `{d, e}` tuple with an integer we get a `MatchError`.

Since we don't have much time, I'll fast forward to match a head and tail of a
list. Because there is a special syntax for that:

[source,elixir]
----
iex> shopping_list = ["apple", "orange", "banana", "pineapple"] <1>
["apple", "orange", "banana", "pineapple"]
iex> [head | tail] = shopping_list <2>
["apple", "orange", "banana", "pineapple"]
iex> head
"apple"
iex> tail
["orange", "banana", "pineapple"]
iex> [a | b] = tail <3>
["orange", "banana", "pineapple"]
iex> a
"orange"
iex> b
["banana", "pineapple"]
iex> [first_product, second_product | tail] = shopping_list <4>
["apple", "orange", "banana", "pineapple"]
iex> first_product
"apple"
iex> second_product
"orange"
iex> tail
["banana", "pineapple"]
iex> [first_product | [second_product | tail]] = shopping_list <5>
["apple", "orange", "banana", "pineapple"]
----
<1> We match a list to the variable `shopping_list`.
<2> `[head | tail]` is the special syntax to match a head and tail of a given list.
<3> Again we match the head `a` and the tail `b` with `tail`.
<4> A bit more complex. We match agains the first and second product followed by a tail.
<5> Same result. Different syntax and logic. Pick the one you prefer.

Of course, if we know that a list has a specific number of elements we can match
it directly:

[source,elixir]
----
iex> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex> [a, b, c, d] = shopping_list
["apple", "orange", "banana", "pineapple"]
iex> a
"apple"
iex> b
"orange"
iex> [e, f, g] = shopping_list <1>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]
----
<1> Just checking. You get an `MatchError` if Elixir can't match both sides.

### Matching Maps

Matching a Map works a little bit different to matching a Tuple or List.
You can match just against the values you are interested in:

[source,elixir]
----
iex> product_prices = %{apple: 0.5, orange: 0.7, pineapple: 1}
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex> %{orange: price} = product_prices <1>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex> price
0.7
iex> %{orange: price1, apple: price2} = product_prices <2>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex> price1
0.7
iex> price2
0.5
----
<1> We can just match one value.
<2> Or we can match multiple values. But we don't have to match the whole Map.

### Matching String parts
indexterm:["Matching String parts"]

Easiest explained with a code example:

[source,elixir]
----
iex> user = "Stefan Wintermeyer"
"Stefan Wintermeyer"
iex> "Stefan " <> last_name = user
"Stefan Wintermeyer"
iex> last_name
"Wintermeyer"
----

NOTE: The left side of a `<>` operator in a match should always be a string.
Otherwise, Elixir can't verify it's size.

### Wildcard Matching
indexterm:["Pattern Matching"]

Sometimes you need pattern matching to get a value, but you don't need all of
the values in the pattern. For those cases, you can use `_` (alone or as a
prefix to a variable name). It indicates to Elixir that you don't need that
variable to be bound to anything.

[source,elixir]
----
iex> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex> [first_product | _tail] = shopping_list <1>
["apple", "orange", "banana", "pineapple"]
iex> first_product
"apple"
iex> [head | _] = shopping_list <2>
["apple", "orange", "banana", "pineapple"]
iex> head
"apple"
----
<1> We pattern match the head of `shopping_list` to `first_product`. But we don't need the tail, and we indicate that by prefixing it with a `_`.
<2> We can use just a `_` too. Using `_tail` just improves the code readability
a bit.

### Pattern Matching with Functions
indexterm:["Pattern Matching with Functions"]

Pattern matching is used everywhere in Elixir. You can even use it with Functions:

[source,elixir]
----
iex> defmodule Area do
...>   def circle(:exact, radius) do <1>
...>     3.14159265359 * radius * radius
...>   end
...>
...>   def circle(:normal, radius) do <2>
...>     3.14 * radius * radius
...>   end
...>
...>   def circle(radius) do <3>
...>     circle(:normal, radius)
...>   end
...> end

iex> Area.circle(:exact, 4)
50.26548245744
iex> Area.circle(:normal, 4)
50.24
iex> Area.circle(4)
50.24
----
<1> We define a `circle/2` function which matches if the first argument is the atom `:exact`.
<2> We define a `circle/2` function which matches if the first argument is the atom `:normal`.
<3> We define a `circle/1` function which calls the `cirle/2` function with the `:normal` argument.

#### Functions with Guards
indexterm:["Guards", "Functions with Guards"]

Guards add some additional spices to pattern matching with functions. You can find
all the details at https://hexdocs.pm/elixir/guards.html

Here are just some examples to show you the concept. Guards start with `when`:

[source,elixir]
----
iex> defmodule Law do
...>   def can_vote?(age) when is_integer(age) and age > 17 do <1>
...>     true
...>   end
...>
...>   def can_vote?(age) when is_integer(age) do <2>
...>     false
...>   end
...>
...>   def can_vote?(_age) do <3>
...>     raise ArgumentError, "age should be an integer"
...>   end
...> end

iex> Law.can_vote?(15)
false
iex> Law.can_vote?(20)
true
iex> Law.can_vote?("test") <4>
** (ArgumentError) age should be an integer
    iex:4: Law.can_vote?/1
----
<1> This guard checks if the `age` argument is an integer and the value of it is bigger than 17.
<2> This guard just checks if the `age` argument is an integer.
<3> This clause catches any value that is not called with an integer.
<4> Since `"test"` is a string and not an integer, the ArgumentError that we
wrote is raised.

## Case
indexterm:["Case"]

`case` is a control structure which matches a given value to a couple of
matching cases until one matches.

Let's assume we want to create a function that converts morse coded
numbers to integers:

[source,elixir]
----
iex> defmodule Morse do
...>   def morse_to_number(input) do
...>     case input do <1>
...>       "-----" -> 0 <2>
...>       ".----" -> 1
...>       "..---" -> 2
...>       "...--" -> 3
...>       "....-" -> 4
...>       "....." -> 5
...>       "-...." -> 6
...>       "--..." -> 7
...>       "---.." -> 8
...>       "----." -> 9
...>       _ -> :error <3>
...>     end
...>   end
...> end

iex> Morse.morse_to_number("-....") <4>
6
----
<1> After `case` comes the value we want to check.
<2> `"-----"` is the expression we want to match to return a 0.
<3> `_` is the catch-all in case nothing matched yet. In this case, return an `:error` atom.
<4> It works. :-)

Of course, we could solve this problem just with functions too. It's up to you what makes the most sense in a given situation.

## if and unless
indexterm:["if", "unless", "else"]

`if` is common to many programming languages. `unless` is equivalent to `if
not`. The following examples will show how to use them:

[source,elixir]
----
iex> if 1 == 1 do
...>   "Bingo!"
...> else
...>   "Negative"
...> end
"Bingo!"
iex> unless true do
...>   "Never"
...> end
nil
----

Sometimes you see a one-line short form:

[source,elixir]
----
iex> if 1 == 1, do: "Bingo!"
"Bingo!"
----

NOTE: Most Elixir developers prefer `case` over `if` or `unless`.

## Immutability
indexterm:["Immutability"]

Probably you have already heard about immutability in Elixir. What's that about?

A variable points to a specific part of the memory where the data is stored. In
many programming languages that data can be changed to update a variable. In
Elixir, you can't change it. So that doesn't mean that you can't rebind a
variable to a different value but that this new value gets a new piece of memory
and doesn't overwrite the old memory. Once a function returns a result and
therefore, has finished its work, everything gets garbage collected (wiped
blank).

Why is that important at all? With immutable variables, we can be sure that
other processes can not change their values while running parallel tasks.  That
has a massive effect. In the end, it means that your Phoenix application can run
on multiple CPUs on the same server in parallel. It even means that your Phoenix
application can share multiple CPUs on several nodes of a server cluster in your
data center; this makes Elixir extremely scalable and save.

But doesn't that make your application slower? Funny thing: No. This way is
faster. It is not efficient to change data in memory.

But don't worry. It is not as complicated as it sounds. Everytime you use a
variable it uses the value of that moment in time. It will not be
effected/changed afterwords:

[source,elixir]
----
iex> product = "Orange"
"Orange"
iex> test1 = fn -> IO.puts(product) end <1>
#Function<21.126501267/0 in :erl_eval.expr/5>
iex> product = "Apple"
"Apple"
iex> test2 = fn -> IO.puts(product) end
#Function<21.126501267/0 in :erl_eval.expr/5>
iex> product = "Pineapple"
"Pineapple"
iex> test3 = fn -> IO.puts(product) end
#Function<21.126501267/0 in :erl_eval.expr/5>
iex> product = "Banana"
"Banana"
iex> test1.() <2>
Orange
:ok
iex> test2.()
Apple
:ok
iex> test3.()
Pineapple
:ok
iex> IO.puts(product)
Banana
:ok
----
<1> Those anonymous functions can run on totally different CPUs. Each one lives
in its own little universe.
<2> The value of `product` has changed multiple times. But for `test1.()` it is
the value from that point in time when we created the function.

## Sigils
indexterm:["Sigils"]

Sigils are another way of representing literals. They start with a tilde (`~`)
character, which is followed by a letter, and then there is some content
surrounded by delimiters.

Let's look at some examples of using the `~s` sigil, which creates a string:

[source,elixir]
----
iex> ~s(Hello, my friend!) <1>
"Hello, my friend!"
iex> ~s(He said, "I hope you are well") <2>
"He said, \"I hope you are well\""
iex> ~s/Hello (Goodbye)/ <3>
"Hello (Goodbye)"
----
<1> In this case, we use the `()` delimiters.
<2> We do not need to escape the double quotes (you will see that they are
escaped in the output).
<3> By changing the delimiters, we do not need to escape the parentheses.

There is also a `~S` (uppercase) sigil, which also creates a string, but does
not support interpolation:

[source,elixir]
----
iex> ~s(1 + 1 = #{1 + 1})
"1 + 1 = 2" <1>
iex> ~S(1 + 1 = #{1 + 1})
"1 + 1 = \#{1 + 1}" <2>
----
<1> The result of `1 + 1` is returned instead of `#{1 + 1}`.
<2> The content is returned as it is written, with no interpolation.

There are 8 different delimiters (having different delimiters means that you can
choose one which reduces the need to escape characters in the content):

[source,elixir]
----
~s/example text/
~s|example text|
~s"example text"
~s'example text'
~s(example text)
~s[example text]
~s{example text}
~s<example text>
----

In the next two subsections, we will see sigils for regular expressions and date
/ time structs. There are also sigils for creating word lists (`~w`) and
charlists (`~c`), and it is also possible for you to create your own sigils.

### Regular expressions
indexterm:["Regular expression"]

`~r` is the sigil used to represent a
https://en.wikipedia.org/wiki/Regular_expression[regular expression]:

[source,elixir]
----
iex> regex = ~r/bcd/
~r/bcd/
iex> "abcde" =~ regex
true
iex> "efghi" =~ regex
false
iex> regex = ~r/stef/i <1>
~r/stef/i
iex> "Stefan" =~ regex
true
----
<1> Modifiers are supported too. For a complete list have a look at https://hexdocs.pm/elixir/Regex.html

### Date and Time

Elixir provides several date / time structs which all have their own sigils.

#### Date
indexterm:["Date"]

Elixir provides a `%Date{}` struct that contains the fields `year`, `month`,
`day` and `calendar`.

With the `~D` sigil, you can create a new `%Date{}` struct:

[source,elixir]
----
iex> birthday = ~D[1973-03-23]
~D[1973-03-23]
iex> birthday.day
23
iex> birthday.month
3
iex> birthday.year
1973
iex> Date.utc_today()
~D[2020-09-23] <1>
----
<1> The return value for many of the functions in the `Date` module use the `~D`
sigil.

#### Time
indexterm:["Time"]

There is a `%Time{}` struct that contains the fields `hour`, `minute`, `second`,
`microsecond` and `calendar`.

With the `~T` sigil, you can create a new `%Time{}` struct:

[source,elixir]
----
iex> now = ~T[09:29:00.0]
~T[09:29:00.0]
iex> now.hour
9
iex> Time.utc_now()
~T[04:57:25.658722] <1>
----
<1> The return value for many of the functions in the `Time` module use the `~T`
sigil.

#### NaiveDateTime
indexterm:["NaiveDateTime"]

The `%NaiveDateTime{}` struct is a combination of `%Date{}` and `%Time{}`.

With the `~N` sigil, you can create a new `%NaiveDateTime{}` struct:

[source,elixir]
----
iex> timestamp = ~N[2020-05-08 09:48:00]
~N[2020-05-08 09:48:00]
----

#### DateTime
indexterm:["DateTime"]

The `%DateTime{}` struct adds timezone information to a `%NaiveDateTime{}`.

You can create a new `%DateTime{}` struct with the `~U` sigil:

[source,elixir]
----
iex> timestamp = ~U[2029-05-08 09:59:03Z]
~U[2029-05-08 09:59:03Z]
iex> DateTime.utc_now()
~U[2020-09-23 04:58:22.403482Z] <1>
----
<1> The return value for many of the functions in the `DateTime` module use the
`~U` sigil.

NOTE: Find more information about timezones and DateTime at https://hexdocs.pm/elixir/DateTime.html

## Recursion
indexterm:["Recursion"]

Recursions are often used when you would use a loop in an object-oriented
language.

Let's write a recursive function which provides a countdown:

[source,elixir]
----
iex> defmodule Example do
...>   def countdown(1) do <1>
...>     IO.puts "1" <2>
...>   end
...>
...>   def countdown(n) when is_integer(n) and n > 1 do <3>
...>     IO.puts Integer.to_string(n) <4>
...>     countdown(n - 1) <5>
...>   end
...> end

iex> Example.countdown(4) <6>
4
3
2
1
:ok
----
<1> If `countdown/1` is called with the argument `1` this is the best match.
<2> We call `IO.puts("1")` to print 1 to STDOUT.
<3> If `countdown/1` is called with an integer bigger than 1 as an argument this function matches.
<4> We have to use `Integer.to_string(n)` to print the integer to STDOUT.
<5> We recursively decrese `n` by 1 and call `countdown/1` with that new number.
<6> It works!

Here's a different example where we calculate the sum of a list of integers:

[source,elixir]
----
iex> defmodule Example do
...>   def sum([]) do <1>
...>     0
...>   end
...>
...>   def sum([head | tail]) do <2>
...>     head + sum(tail) <3>
...>   end
...> end

iex> Example.sum([10, 8, 12, 150]) <4>
180
iex> [head | tail] = [150] <5>
[150]
iex> tail
[]
----
<1> The sum of an empty list is 0.
<2> We pattern match a list and split it into a `head` and a `tail`.
<3> We add the current `head` to the sum of the `tail`.
<4> It works!
<5> This is just to show how Elixir handles the case of a list with one element.

You can use the same concept to transform every element of a list. Let's assume
we want to double the value of every element of a list:

[source,elixir]
----
iex> defmodule Example do
...>   def double([]) do <1>
...>     []
...>   end
...>
...>   def double([head | tail]) do
...>     [head * 2 | double(tail)] <2>
...>   end
...> end

iex> Ex
Example      Exception
iex> Example.double([10, 5, 999])
[20, 10, 1998]
----
<1> We again start with the most simple match. An empty list. That will result in an empty list.
<2> The `[head | tail]` syntax works both ways. We can use it to build a list too.

### How to tackle a recursion

Unless you are doing this every day, you will get to problems where you know
that recursion is a good solution, but you just can't think of a good recursion
for it.

Let me share a pro tip for these situations: https://www.google.com and
https://stackoverflow.com are my lifesavers in such cases. No embarrassment!

During this book, we will work with recursions. So you'll get a better feeling for
it.

## mix
indexterm:["mix"]

By now, you understand the basics of Elixir. The next step is to create an
application. In the Elixir ecosystem, this is done with the (already installed)
command-line interface (CLI) `mix`. Let's do that for a "Hello world!"
application:

[source,bash]
----
$ mix new hello_world
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/hello_world.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_world_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd hello_world
    mix test

Run "mix help" for more commands.
----

The command ´mix new projectname` creates a new directory with the name `projectname`
and fills it with a default structure:

[source,bash]
----
$ cd hello_world
$ tree
.
├── README.md
├── lib
│   └── hello_world.ex
├── mix.exs
└── test
    ├── hello_world_test.exs
    └── test_helper.exs

2 directories, 5 files
----

The Phoenix directory structure will be more involved but has the same core.

## mix tasks
indexterm:["mix tasks", "task]

A task is a mechanism to start code with `mix`. For our "Hello world!"
programme we have to create the directory `lib/mix/tasks` and create the file
`lib/mix/tasks/start.ex` with this code:

lib/mix/tasks/start.ex
[source,elixir]
----
defmodule Mix.Tasks.Start do
  use Mix.Task

  def run(_) do <1>
    IO.puts "Hello world!"
  end
end
----
<1> The `run(_)` function is the default function which gets called automatically.

Now we can start the `mix start` task:

[source,bash]
----
$ mix start
Compiling 1 file (.ex)
Generated hello_world app
Hello world!
----

The `.ex` file gets compiled, and the `start` task gets run. The compile is only
done when needed. If we call `mix start` a second time no compile is needed:

[source,bash]
----
$ mix start
Hello world!
----

Obviously `mix` as a topic is much more complicated. In this section, I just
wanted to show you the very basic idea of `mix` so that you know where to search
if you want to know what happens if you do a `mix server` with a Phoenix
application.

## mix format
indexterm:["mix tasks", "task"]

You are going to love `mix format`. You can call it in the root directory of
your Phoenix application and it will autoformat all your Elixir source code
files.

You should use `mix format` every time you are going to commit code to a
repository.

## What else?

This chapter just deals with the tip of the iceberg. It provides the basic
knowledge that you need to start with the Phoenix Framework. There is a lot more
to learn. But I wouldn't worry too much about that right now. You are good to
go for the next chapter of this book. Have fun!

### Elixir Books

If you want to dive more into Elixir than I recommend the following
books:

- https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir[Learn Functional Programming with Elixir] by Ulisses Almeida (https://twitter.com/ulissesalmeida[@ulissesalmeida])
+
In my opinion, the best beginners book for Elixir.
- https://pragprog.com/book/elixir16/programming-elixir-1-6[Programming Elixir 1.6] by Dave Thomas (https://twitter.com/pragdave[@pragdave])
+
Dave - as always - wrote a very book which shines a light into many details.
