
## Pattern Matching
indexterm:["Pattern Matching"]

Pattern matching is essential in Elixir, and we have already used it, without
knowing it, for binding values to variables.

[source,elixir]
----
iex> a = 10 <1>
10
iex> a
10
iex> {b, c} = {10, 15} <2>
{10, 15}
iex> b
10
iex> c
15
iex> {d, e} = 100
** (MatchError) no match of right hand side value: 100 <3>
----
<1> This is actually a pattern match. The left side of `=` will be matched to the right site if possible.
<2> Here we pattern match `{b, c}` on the left side with a tuple on the right side.
<3> Boom! Because we can not match the `{d, e}` tuple with an integer we get a `MatchError`.

Since we don't have much time, I'll fast forward to match a head and tail of a
list. Because there is a special syntax for that:

[source,elixir]
----
iex> shopping_list = ["apple", "orange", "banana", "pineapple"] <1>
["apple", "orange", "banana", "pineapple"]
iex> [head | tail] = shopping_list <2>
["apple", "orange", "banana", "pineapple"]
iex> head
"apple"
iex> tail
["orange", "banana", "pineapple"]
iex> [a | b] = tail <3>
["orange", "banana", "pineapple"]
iex> a
"orange"
iex> b
["banana", "pineapple"]
iex> [first_product, second_product | tail] = shopping_list <4>
["apple", "orange", "banana", "pineapple"]
iex> first_product
"apple"
iex> second_product
"orange"
iex> tail
["banana", "pineapple"]
iex> [first_product | [second_product | tail]] = shopping_list <5>
["apple", "orange", "banana", "pineapple"]
----
<1> We match a list to the variable `shopping_list`.
<2> `[head | tail]` is the special syntax to match a head and tail of a given list.
<3> Again we match the head `a` and the tail `b` with `tail`.
<4> A bit more complex. We match agains the first and second product followed by a tail.
<5> Same result. Different syntax and logic. Pick the one you prefer.

Of course, if we know that a list has a specific number of elements we can match
it directly:

[source,elixir]
----
iex> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex> [a, b, c, d] = shopping_list
["apple", "orange", "banana", "pineapple"]
iex> a
"apple"
iex> b
"orange"
iex> [e, f, g] = shopping_list <1>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]
----
<1> Just checking. You get an `MatchError` if Elixir can't match both sides.

### Matching Maps

Matching a Map works a little bit different to matching a Tuple or List.
You can match just against the values you are interested in:

[source,elixir]
----
iex> product_prices = %{apple: 0.5, orange: 0.7, pineapple: 1}
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex> %{orange: price} = product_prices <1>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex> price
0.7
iex> %{orange: price1, apple: price2} = product_prices <2>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex> price1
0.7
iex> price2
0.5
----
<1> We can just match one value.
<2> Or we can match multiple values. But we don't have to match the whole Map.

### Matching String parts
indexterm:["Matching String parts"]

Easiest explained with a code example:

[source,elixir]
----
iex> user = "Stefan Wintermeyer"
"Stefan Wintermeyer"
iex> "Stefan " <> last_name = user
"Stefan Wintermeyer"
iex> last_name
"Wintermeyer"
----

NOTE: The left side of a `<>` operator in a match should always be a string.
Otherwise, Elixir can't verify it's size.

### Wildcard Matching
indexterm:["Pattern Matching"]

Sometimes you need pattern matching to get a value, but you don't need all of
the values in the pattern. For those cases, you can use `_` (alone or as a
prefix to a variable name). It indicates to Elixir that you don't need that
variable to be bound to anything.

[source,elixir]
----
iex> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex> [first_product | _tail] = shopping_list <1>
["apple", "orange", "banana", "pineapple"]
iex> first_product
"apple"
iex> [head | _] = shopping_list <2>
["apple", "orange", "banana", "pineapple"]
iex> head
"apple"
----
<1> We pattern match the head of `shopping_list` to `first_product`. But we don't need the tail, and we indicate that by prefixing it with a `_`.
<2> We can use just a `_` too. Using `_tail` just improves the code readability
a bit.

### Pattern Matching with Functions
indexterm:["Pattern Matching with Functions"]

Pattern matching is used everywhere in Elixir. You can even use it with Functions:

[source,elixir]
----
iex> defmodule Area do
...>   def circle(:exact, radius) do <1>
...>     3.14159265359 * radius * radius
...>   end
...>
...>   def circle(:normal, radius) do <2>
...>     3.14 * radius * radius
...>   end
...>
...>   def circle(radius) do <3>
...>     circle(:normal, radius)
...>   end
...> end

iex> Area.circle(:exact, 4)
50.26548245744
iex> Area.circle(:normal, 4)
50.24
iex> Area.circle(4)
50.24
----
<1> We define a `circle/2` function which matches if the first argument is the atom `:exact`.
<2> We define a `circle/2` function which matches if the first argument is the atom `:normal`.
<3> We define a `circle/1` function which calls the `cirle/2` function with the `:normal` argument.

#### Functions with Guards
indexterm:["Guards", "Functions with Guards"]

Guards add some additional spices to pattern matching with functions. You can find
all the details at https://hexdocs.pm/elixir/guards.html

Here are just some examples to show you the concept. Guards start with `when`:

[source,elixir]
----
iex> defmodule Law do
...>   def can_vote?(age) when is_integer(age) and age > 17 do <1>
...>     true
...>   end
...>
...>   def can_vote?(age) when is_integer(age) do <2>
...>     false
...>   end
...>
...>   def can_vote?(_age) do <3>
...>     raise ArgumentError, "age should be an integer"
...>   end
...> end

iex> Law.can_vote?(15)
false
iex> Law.can_vote?(20)
true
iex> Law.can_vote?("test") <4>
** (ArgumentError) age should be an integer
    iex:4: Law.can_vote?/1
----
<1> This guard checks if the `age` argument is an integer and the value of it is bigger than 17.
<2> This guard just checks if the `age` argument is an integer.
<3> This clause catches any value that is not called with an integer.
<4> Since `"test"` is a string and not an integer, the ArgumentError that we
wrote is raised.

## Case
indexterm:["Case"]

`case` is a control structure which matches a given value to a couple of
matching cases until one matches.

Let's assume we want to create a function that converts morse coded
numbers to integers:

[source,elixir]
----
iex> defmodule Morse do
...>   def morse_to_number(input) do
...>     case input do <1>
...>       "-----" -> 0 <2>
...>       ".----" -> 1
...>       "..---" -> 2
...>       "...--" -> 3
...>       "....-" -> 4
...>       "....." -> 5
...>       "-...." -> 6
...>       "--..." -> 7
...>       "---.." -> 8
...>       "----." -> 9
...>       _ -> :error <3>
...>     end
...>   end
...> end

iex> Morse.morse_to_number("-....") <4>
6
----
<1> After `case` comes the value we want to check.
<2> `"-----"` is the expression we want to match to return a 0.
<3> `_` is the catch-all in case nothing matched yet. In this case, return an `:error` atom.
<4> It works. :-)

Of course, we could solve this problem just with functions too. It's up to you what makes the most sense in a given situation.

## if and unless
indexterm:["if", "unless", "else"]

`if` is common to many programming languages. `unless` is equivalent to `if
not`. The following examples will show how to use them:

[source,elixir]
----
iex> if 1 == 1 do
...>   "Bingo!"
...> else
...>   "Negative"
...> end
"Bingo!"
iex> unless true do
...>   "Never"
...> end
nil
----

Sometimes you see a one-line short form:

[source,elixir]
----
iex> if 1 == 1, do: "Bingo!"
"Bingo!"
----

NOTE: Most Elixir developers prefer `case` over `if` or `unless`.

## Immutability
indexterm:["Immutability"]

Probably you have already heard about immutability in Elixir. What's that about?

A variable points to a specific part of the memory where the data is stored. In
many programming languages that data can be changed to update a variable. In
Elixir, you can't change it. So that doesn't mean that you can't rebind a
variable to a different value but that this new value gets a new piece of memory
and doesn't overwrite the old memory. Once a function returns a result and
therefore, has finished its work, everything gets garbage collected (wiped
blank).

Why is that important at all? With immutable variables, we can be sure that
other processes can not change their values while running parallel tasks.  That
has a massive effect. In the end, it means that your Phoenix application can run
on multiple CPUs on the same server in parallel. It even means that your Phoenix
application can share multiple CPUs on several nodes of a server cluster in your
data center; this makes Elixir extremely scalable and save.

But doesn't that make your application slower? Funny thing: No. This way is
faster. It is not efficient to change data in memory.

But don't worry. It is not as complicated as it sounds. Everytime you use a
variable it uses the value of that moment in time. It will not be
effected/changed afterwords:

[source,elixir]
----
iex> product = "Orange"
"Orange"
iex> test1 = fn -> IO.puts(product) end <1>
#Function<21.126501267/0 in :erl_eval.expr/5>
iex> product = "Apple"
"Apple"
iex> test2 = fn -> IO.puts(product) end
#Function<21.126501267/0 in :erl_eval.expr/5>
iex> product = "Pineapple"
"Pineapple"
iex> test3 = fn -> IO.puts(product) end
#Function<21.126501267/0 in :erl_eval.expr/5>
iex> product = "Banana"
"Banana"
iex> test1.() <2>
Orange
:ok
iex> test2.()
Apple
:ok
iex> test3.()
Pineapple
:ok
iex> IO.puts(product)
Banana
:ok
----
<1> Those anonymous functions can run on totally different CPUs. Each one lives
in its own little universe.
<2> The value of `product` has changed multiple times. But for `test1.()` it is
the value from that point in time when we created the function.

## Sigils
indexterm:["Sigils"]

Sigils are another way of representing literals. They start with a tilde (`~`)
character, which is followed by a letter, and then there is some content
surrounded by delimiters.

Let's look at some examples of using the `~s` sigil, which creates a string:

[source,elixir]
----
iex> ~s(Hello, my friend!) <1>
"Hello, my friend!"
iex> ~s(He said, "I hope you are well") <2>
"He said, \"I hope you are well\""
iex> ~s/Hello (Goodbye)/ <3>
"Hello (Goodbye)"
----
<1> In this case, we use the `()` delimiters.
<2> We do not need to escape the double quotes (you will see that they are
escaped in the output).
<3> By changing the delimiters, we do not need to escape the parentheses.

There is also a `~S` (uppercase) sigil, which also creates a string, but does
not support interpolation:

[source,elixir]
----
iex> ~s(1 + 1 = #{1 + 1})
"1 + 1 = 2" <1>
iex> ~S(1 + 1 = #{1 + 1})
"1 + 1 = \#{1 + 1}" <2>
----
<1> The result of `1 + 1` is returned instead of `#{1 + 1}`.
<2> The content is returned as it is written, with no interpolation.

There are 8 different delimiters (having different delimiters means that you can
choose one which reduces the need to escape characters in the content):

[source,elixir]
----
~s/example text/
~s|example text|
~s"example text"
~s'example text'
~s(example text)
~s[example text]
~s{example text}
~s<example text>
----

In the next two subsections, we will see sigils for regular expressions and date
/ time structs. There are also sigils for creating word lists (`~w`) and
charlists (`~c`), and it is also possible for you to create your own sigils.

### Regular expressions
indexterm:["Regular expression"]

`~r` is the sigil used to represent a
https://en.wikipedia.org/wiki/Regular_expression[regular expression]:

[source,elixir]
----
iex> regex = ~r/bcd/
~r/bcd/
iex> "abcde" =~ regex
true
iex> "efghi" =~ regex
false
iex> regex = ~r/stef/i <1>
~r/stef/i
iex> "Stefan" =~ regex
true
----
<1> Modifiers are supported too. For a complete list have a look at https://hexdocs.pm/elixir/Regex.html

### Date and Time

Elixir provides several date / time structs which all have their own sigils.

#### Date
indexterm:["Date"]

Elixir provides a `%Date{}` struct that contains the fields `year`, `month`,
`day` and `calendar`.

With the `~D` sigil, you can create a new `%Date{}` struct:

[source,elixir]
----
iex> birthday = ~D[1973-03-23]
~D[1973-03-23]
iex> birthday.day
23
iex> birthday.month
3
iex> birthday.year
1973
iex> Date.utc_today()
~D[2020-09-23] <1>
----
<1> The return value for many of the functions in the `Date` module use the `~D`
sigil.

#### Time
indexterm:["Time"]

There is a `%Time{}` struct that contains the fields `hour`, `minute`, `second`,
`microsecond` and `calendar`.

With the `~T` sigil, you can create a new `%Time{}` struct:

[source,elixir]
----
iex> now = ~T[09:29:00.0]
~T[09:29:00.0]
iex> now.hour
9
iex> Time.utc_now()
~T[04:57:25.658722] <1>
----
<1> The return value for many of the functions in the `Time` module use the `~T`
sigil.

#### NaiveDateTime
indexterm:["NaiveDateTime"]

The `%NaiveDateTime{}` struct is a combination of `%Date{}` and `%Time{}`.

With the `~N` sigil, you can create a new `%NaiveDateTime{}` struct:

[source,elixir]
----
iex> timestamp = ~N[2020-05-08 09:48:00]
~N[2020-05-08 09:48:00]
----

#### DateTime
indexterm:["DateTime"]

The `%DateTime{}` struct adds timezone information to a `%NaiveDateTime{}`.

You can create a new `%DateTime{}` struct with the `~U` sigil:

[source,elixir]
----
iex> timestamp = ~U[2029-05-08 09:59:03Z]
~U[2029-05-08 09:59:03Z]
iex> DateTime.utc_now()
~U[2020-09-23 04:58:22.403482Z] <1>
----
<1> The return value for many of the functions in the `DateTime` module use the
`~U` sigil.

NOTE: Find more information about timezones and DateTime at https://hexdocs.pm/elixir/DateTime.html

## Recursion
indexterm:["Recursion"]

Recursions are often used when you would use a loop in an object-oriented
language.

Let's write a recursive function which provides a countdown:

[source,elixir]
----
iex> defmodule Example do
...>   def countdown(1) do <1>
...>     IO.puts "1" <2>
...>   end
...>
...>   def countdown(n) when is_integer(n) and n > 1 do <3>
...>     IO.puts Integer.to_string(n) <4>
...>     countdown(n - 1) <5>
...>   end
...> end

iex> Example.countdown(4) <6>
4
3
2
1
:ok
----
<1> If `countdown/1` is called with the argument `1` this is the best match.
<2> We call `IO.puts("1")` to print 1 to STDOUT.
<3> If `countdown/1` is called with an integer bigger than 1 as an argument this function matches.
<4> We have to use `Integer.to_string(n)` to print the integer to STDOUT.
<5> We recursively decrese `n` by 1 and call `countdown/1` with that new number.
<6> It works!

Here's a different example where we calculate the sum of a list of integers:

[source,elixir]
----
iex> defmodule Example do
...>   def sum([]) do <1>
...>     0
...>   end
...>
...>   def sum([head | tail]) do <2>
...>     head + sum(tail) <3>
...>   end
...> end

iex> Example.sum([10, 8, 12, 150]) <4>
180
iex> [head | tail] = [150] <5>
[150]
iex> tail
[]
----
<1> The sum of an empty list is 0.
<2> We pattern match a list and split it into a `head` and a `tail`.
<3> We add the current `head` to the sum of the `tail`.
<4> It works!
<5> This is just to show how Elixir handles the case of a list with one element.

You can use the same concept to transform every element of a list. Let's assume
we want to double the value of every element of a list:

[source,elixir]
----
iex> defmodule Example do
...>   def double([]) do <1>
...>     []
...>   end
...>
...>   def double([head | tail]) do
...>     [head * 2 | double(tail)] <2>
...>   end
...> end

iex> Ex
Example      Exception
iex> Example.double([10, 5, 999])
[20, 10, 1998]
----
<1> We again start with the most simple match. An empty list. That will result in an empty list.
<2> The `[head | tail]` syntax works both ways. We can use it to build a list too.

### How to tackle a recursion

Unless you are doing this every day, you will get to problems where you know
that recursion is a good solution, but you just can't think of a good recursion
for it.

Let me share a pro tip for these situations: https://www.google.com and
https://stackoverflow.com are my lifesavers in such cases. No embarrassment!

During this book, we will work with recursions. So you'll get a better feeling for
it.

## mix
indexterm:["mix"]

By now, you understand the basics of Elixir. The next step is to create an
application. In the Elixir ecosystem, this is done with the (already installed)
command-line interface (CLI) `mix`. Let's do that for a "Hello world!"
application:

[source,bash]
----
$ mix new hello_world
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/hello_world.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_world_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd hello_world
    mix test

Run "mix help" for more commands.
----

The command ´mix new projectname` creates a new directory with the name `projectname`
and fills it with a default structure:

[source,bash]
----
$ cd hello_world
$ tree
.
├── README.md
├── lib
│   └── hello_world.ex
├── mix.exs
└── test
    ├── hello_world_test.exs
    └── test_helper.exs

2 directories, 5 files
----

The Phoenix directory structure will be more involved but has the same core.

## mix tasks
indexterm:["mix tasks", "task]

A task is a mechanism to start code with `mix`. For our "Hello world!"
programme we have to create the directory `lib/mix/tasks` and create the file
`lib/mix/tasks/start.ex` with this code:

lib/mix/tasks/start.ex
[source,elixir]
----
defmodule Mix.Tasks.Start do
  use Mix.Task

  def run(_) do <1>
    IO.puts "Hello world!"
  end
end
----
<1> The `run(_)` function is the default function which gets called automatically.

Now we can start the `mix start` task:

[source,bash]
----
$ mix start
Compiling 1 file (.ex)
Generated hello_world app
Hello world!
----

The `.ex` file gets compiled, and the `start` task gets run. The compile is only
done when needed. If we call `mix start` a second time no compile is needed:

[source,bash]
----
$ mix start
Hello world!
----

Obviously `mix` as a topic is much more complicated. In this section, I just
wanted to show you the very basic idea of `mix` so that you know where to search
if you want to know what happens if you do a `mix server` with a Phoenix
application.

## mix format
indexterm:["mix tasks", "task"]

You are going to love `mix format`. You can call it in the root directory of
your Phoenix application and it will autoformat all your Elixir source code
files.

You should use `mix format` every time you are going to commit code to a
repository.

## What else?

This chapter just deals with the tip of the iceberg. It provides the basic
knowledge that you need to start with the Phoenix Framework. There is a lot more
to learn. But I wouldn't worry too much about that right now. You are good to
go for the next chapter of this book. Have fun!

### Elixir Books

If you want to dive more into Elixir than I recommend the following
books:

- https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir[Learn Functional Programming with Elixir] by Ulisses Almeida (https://twitter.com/ulissesalmeida[@ulissesalmeida])
+
In my opinion, the best beginners book for Elixir.
- https://pragprog.com/book/elixir16/programming-elixir-1-6[Programming Elixir 1.6] by Dave Thomas (https://twitter.com/pragdave[@pragdave])
+
Dave - as always - wrote a very book which shines a light into many details.
