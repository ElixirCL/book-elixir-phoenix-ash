[[elixir_introduction]]
## Elixir Introduction

This chapter will teach you the absolut basics of Elixir. There is a lot more to
learn and to understand about Elixir. The content of this chapter is just enough
to use Phoenix.

NOTE: All code examples are tested with Elixir version 10.2.

[[elixir-introduction-iex]]
### Elixir's Interactive Shell (iex)

Your Elixir installation comes with an Elixir's Interactive Shell (`iex`) which we 
will use for most examples in this chapter. Please go to your command line and 
fire it up:
indexterm:["iex", "Elixir's Interactive Shell"]

[source,elixir]
----
$ iex 
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> <1>
----
<1> This is your iex prompt.

IMPORTANT: You have to press `CTRL-C` twice(!) to stop the `iex`.

The `iex` will be your trusted friend during the work with this book and later
while working with Phoenix. While programming in development mode you can use it 
to dive into the core of your Phoenix application. You can do so too while 
being in production mode but that is the equivalent to an open heard surgery. It can 
be a life saver but you really need to know what you are doing.

TIP: The iex offers autocomplete when possible. So when in doubt press `TAB`.

TIP: The iex offers a history too. To recycle the last command just press on the arrow-up key.

[[elixir-introduction-hello-world]]
### Hello world!

The classic! But never the less very important. You can use the function `IO.puts()`
to print a string to standard output:

[source,elixir]
----
iex(1)> IO.puts("Hello world!")
Hello world!
:ok
----
indexterm:["Hello World!"]

Strings are always encapsuled within double quotes. In case you need to have 
double quotes within a string you have to escape them with backslashes:

[source,elixir]
----
iex(2)> IO.puts("With double quotes: \"Hello world!\"")
With double quotes: "Hello world!"
:ok
iex(3)>
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C<1>
----
<1> Don't be afraid of the `BREAK` menue. With the first `Ctrl+C` the `iex`
displays this list of choices (the `BREAK` menu) and with the second `Ctrl+C`
you end the `iex`.
indexterm:["BREAK menue"]

[[elixir-introduction-basic-calculations]]
### Basic Calculations

We can use the types `integer` (Integer numbers) and `float` (Real numbers) to
do all sorts of calcuations. We can use the usual operators. I'll show you a
couple of examples:

[source,elixir]
----
$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 1 + 1
2
iex(2)> 1.1 + 1
2.1
iex(3)> 2 - 1
1
iex(4)> 10 * 1000000000000000
10000000000000000
iex(5)> 23 / 3
7.666666666666667
iex(6)> 
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C
----

NOTE: If it's OK with you I'll skip the `iex` and the `BREAK` part in the rest
of this chapter. By that we get more real estate for the essential stuff.

[[elixir-introduction-logical-expressions]]
### Logical Expressions

A type `boolean` can store the values `true` and `false`. Together with `and`,
`or` and `not` those can create expressions:

[source,elixir]
----
iex(1)> true and true
true
iex(2)> false and false
false
iex(3)> true or false
true
iex(4)> not true
false
----
indexterm:["Logical Expressions"]

The operators `and`, `or` and `not` can only work with boolean values. The operators 
`&&` (and), `||` (or) and `!` (not) basically do the same but are a bit more free spirited and accept *truthy* and *falsy* values. We will get to that later if needed.

[[elixir-introduction-variables]]
### Variables
indexterm:["Variables"]

You already know how variables work from experiences in other programming
languages. Therefor we can dive right into it. Variable names follow the
[snake_case](https://en.wikipedia.org/wiki/Snake_case) format and start with a
lower case. Some examples:

[source,elixir]
----
iex(1)> length = 10 <1>
10
iex(2)> width = 23
23
iex(3)> area = length * width
230
----
<1> We use the operator `=` to bind the value 10 to the variable with the name `length`.

If you start a variable name with a capital error you'll get an error:

[source,elixir]
----
iex(4)> Radius = 2
** (MatchError) no match of right hand side value: 2 <1>
----
<1> Yes, `MatchError` is a rather strange error message here. It will make more
sense later. Binding values in variables is a bit more complicated than it seems
right now.

[[elixir-introduction-strings]]
### Strings
indexterm:["Strings"]

We already used a string in the <<elixir-introduction-hello-worlds,Hello World>> example. 
The use is for variables is straight forward:

[source,elixir]
----
iex(1)> first_name = "Stefan" <1>
"Stefan"
iex(2)> last_name = "Wintermeyer"
"Wintermeyer"
iex(3)> name = first_name <> " " <> last_name <2>
"Stefan Wintermeyer"
iex(4)> greeting = "Hello #{first_name}!" <3>
"Hello Stefan!"
iex(5)> counter = 23
23
iex(6)> "Count: #{counter}" <4>
"Count: 23"
----
<1> We assign the string "Stefan" to the variable with the name `first_name`.
<2> The `<>` operator can be used to concatinate strings.
indexterm:["<> operator"]
<3> `#{}` is Elixir's expressive string-interpolation. 
It can be used to inject a variable into a string which is encapsuled 
within double quotes.
<4> Elixir's expressive string-interpolation even works with integers. 
String-interpolation is done by the `Kernel.to_string/1` macro which evokes 
`String.Chars`. It can handle integers, floats, some lists (later more on lists) 
and atoms (later more on atoms) out of the box.
indexterm:["String-Interpolation"]

### Anonymous Functions
indexterm:["Functions", "Anonymous Functions"]

Functions are the method in a functional programming language to handle subprograms. 
Let me show you an example:

[source,elixir]
----
iex(1)> greeting = fn name -> "Hello #{name}!" end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> greeting.("Bob") <2>
"Hello Bob!"
iex(3)> greeting.("Alice")
"Hello Alice!"
iex(4)> square_area = fn(a) -> a * a end <3>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(5)> square_area.(10)
100
----
<1> We create a function and bind it to the variable `greeting`. 
* `fn` tells Elixir that you want to define a function.
* `name` is a parameter we can use to inject values.
* `->` is the operator to indicate the the following expression is the body of the function.
* `end` indicates the end of the function.
<2> We use the `.` (dot) operator to pass a value to the function.
<3> Feel free to use parentheses: `fn(a)`

These simple functions are called *anonymous functions*. They have no global 
name and must be bound to a variable.

Most times anonmous functions are simple one liners. But they don't have to be:

[source,elixir]
----
iex(1)> circular_area = fn radius -> 
...(1)>   pi = 3.14159265359
...(1)>   pi * radius * radius
...(1)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> circular_area.(3)
28.274333882310003
----

Sometimes it makes sense to create a function without an argument:

[source,elixir]
----
iex(1)> tomorrow = fn -> Date.add(Date.utc_today(), 1) end <1>
#Function<21.126501267/0 in :erl_eval.expr/5>
iex(2)> tomorrow.() <2>
~D[2020-05-07]
iex(3)> Date.utc_today() <3>
~D[2020-05-06]
iex(4)> tomorrow <4>
#Function<21.126501267/0 in :erl_eval.expr/5>
----
<1> Yes, we haven't discussed `Date.add` or `Date.utc_today()` yet. But you are smart enough to figure out what they do.
<2> Call the function `tomorrow` without a parameter.
<3> Just double check.
<4> Calling `tomorrow` without the `.` (dot) operator will not trigger the function.

Sometimes you need a function with multiple arguments. Those are seperated by commas:

[source,elixir]
----
iex(1)> area = fn a, b -> a * b end <1>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex(2)> area.(2,8)
16
iex(3)> volumne = fn a, b, c -> a * b * c end
#Function<19.126501267/3 in :erl_eval.expr/5>
iex(4)> volumne.(10,10,10) <2>
1000
----
<1> Two parameters (a and b).
<2> Three parameters (a, b and c).

NOTE: A function can not have more than 255 parameters. As a rule of thumb I suggest you never 
use more than 5 parameters. That is always an indicator that you should refactor your code.

#### Functions are First-Class Citizens

In Elixir a function is a value of the type `function`. So they are just like any 
other value. That means you can programm a function that expects an other function as 
a parameter.

It's hard to find a somehow meaningful example for this with our current Elixir
know-how. Germany has two kinds of value added taxes (VAT). The default is 19%
and the reduced one (e.g. for some foods) is 7%.

[source,elixir]
----
iex(1)> food_vat = fn price -> price * 0.07 end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> vat = fn price -> price * 0.19 end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> total_price = fn price, vat -> price + vat.(price) end <3>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex(4)> total_price.(10, food_vat) <4>
10.7   
iex(5)> total_price.(10, vat)
11.9
----
<1> This function calculates the 7% VAT.
<2> This function calculates the 19% VAT.
<3> This function calculates the total price which includes the tax. You see that the second parameter is a function.
<4> Example calculation which uses the `food_vat` function as the second parameter.

### The & operator

It is likely that you will stumble upon the `&` operator while searching
solutions for Elixir problems. It is a so called *capture operator*. It 
is a syntactical shortcut.

[source,elixir]
----
iex(1)> square_area = fn a -> a * a end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> square_area2 = &(&1 * &1) <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> square_area.(8)
64
iex(4)> square_area2.(9)
81
iex(5)> rectangle_area = &(&1 * &2) <3>
&:erlang.*/2
iex(6)> rectangle_area.(7,8)
56
----
<1> A normal anonymous function to calculate the area of a square.
<2> The same calculation but a different syntax. We use the & operator. No need for a `fn` and `end` with this operator.
<3> Multiple parameter can be used too (e.g. `&1`, `&2`).

Sometimes it is easier to read code which uses the `&` operator. Sometimes it is not.

### Variable Scopes

In every programming language variables have some sort of scope. Let's have a look 
into some code to figure out how variables in Elixr are scoped:

[source,elixir]
----
iex(1)> area = 5 <1>
5
iex(2)> IO.puts(area)
5
:ok
iex(3)> square_area = fn a -> <2>
...(3)>   area = a * a <3>
...(3)>   area
...(3)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(4)> square_area.(10) <4>
100
iex(5)> IO.puts(area) <5> 
5
:ok
----
<1> We bind the value of 5 to the variable `area`.
<2> We define an anonymous function.
<3> Within this function we bind the result of our calculation to an other variable `area`.
<4> Run the function with the parameter 10. That would mean that the `area` in the function gets set to the value 100.
<5> The original `area` hasn't changed a bit. Because it is in a different scope.

The `area` within the function is in an inner scope. The original `area` is in an outer scope.

But it gets a bit more complex:

[source,elixir]
----
iex(1)> pi = 3.14159265359 <1>
3.14159265359
iex(2)> circular_area = fn radius -> pi * radius * radius end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> circular_area.(10)
314.15926535899996
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We create an anonymous function which uses the variable `pi` to make the calculation.

So we can read the outer scope variable from within the function. So lets check if we can change it too:

[source,elixir]
----
iex(1)> pi = 3.14159265359 <1>
3.14159265359
iex(2)> circular_area = fn radius ->
...(2)>   pi = 3.14 <2>
...(2)>   pi * radius * radius
...(2)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> circular_area.(10) <3>
314.0
iex(4)> IO.puts(pi) <4>
3.14159265359
:ok
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We bind the inner scoped variable `pi` with the value 3.14.
<3> The 3.14 and not the 3.14159265359 gets used.
<4> The outer scoped `pi` is not changed.