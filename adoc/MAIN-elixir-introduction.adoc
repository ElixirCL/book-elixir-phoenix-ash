[[elixir_introduction]]
## Elixir Introduction

This chapter will teach you the absolut basics of Elixir. There is a lot more to
learn and to understand about Elixir. The content of this chapter is just enough
to use Phoenix.

NOTE: All code examples are tested with Elixir version 10.2.

[[elixir-introduction-iex]]
### Elixir's Interactive Shell (iex)

Your Elixir installation comes with an Elixir's Interactive Shell (`iex`) which we 
will use for most examples in this chapter. Please go to your command line and 
fire it up:
indexterm:["iex", "Elixir's Interactive Shell"]

[source,elixir]
----
$ iex 
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> <1>
----
<1> This is your iex prompt.

IMPORTANT: You have to press `CTRL-C` twice(!) to stop the `iex`.

The `iex` will be your trusted friend during the work with this book and later
while working with Phoenix. While programming in development mode you can use it 
to dive into the core of your Phoenix application. You can do so too while 
being in production mode but that is the equivalent to an open heard surgery. It can 
be a life saver but you really need to know what you are doing.

TIP: The iex offers autocomplete when possible. So when in doubt press `TAB`.

TIP: The iex offers a history too. To recycle the last command just press on the arrow-up key.

[[elixir-introduction-hello-world]]
### Hello world!

The classic! But never the less very important. You can use the function `IO.puts()`
to print a string to standard output:

[source,elixir]
----
iex(1)> IO.puts("Hello world!")
Hello world!
:ok
----
indexterm:["Hello World!"]

Strings are always encapsuled within double quotes. In case you need to have 
double quotes within a string you have to escape them with backslashes:

[source,elixir]
----
iex(2)> IO.puts("With double quotes: \"Hello world!\"")
With double quotes: "Hello world!"
:ok
iex(3)>
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C<1>
----
<1> Don't be afraid of the `BREAK` menue. With the first `Ctrl+C` the `iex`
displays this list of choices (the `BREAK` menu) and with the second `Ctrl+C`
you end the `iex`.
indexterm:["BREAK menue"]

[[elixir-introduction-basic-calculations]]
### Basic Calculations

We can use the types `integer` (Integer numbers) and `float` (Real numbers) to
do all sorts of calcuations. We can use the usual operators. I'll show you a
couple of examples:

[source,elixir]
----
$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 1 + 1
2
iex(2)> 1.1 + 1
2.1
iex(3)> 2 - 1
1
iex(4)> 10 * 1000000000000000
10000000000000000
iex(5)> 23 / 3
7.666666666666667
iex(6)> 
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C
----

NOTE: If it's OK with you I'll skip the `iex` and the `BREAK` part in the rest
of this chapter. By that we get more real estate for the essential stuff and less trees 
have to die to get the book version printed.

[[elixir-introduction-atoms]]
### Atoms

An atom just consists of it's own name. In some other programming languages they 
are called symbols. Atoms start with a `:`

[source,elixir]
----
iex(1)> :red
:red
iex(2)> :blue
:blue
----

NOTE: Atom names can be written in snake_case or in CamelCase. But the usual Elixir 
convention is to use snake_case.

#### Booleans are atoms too

Booleans are a good example for the use of atoms. But they are special because 
you don't have to prefix them with a `:`.

[source,elixir]
----
iex(1)> false == :false <1>
true
iex(2)> is_atom(false) <2>
true
iex(3)> is_boolean(:false) <3>
true
----
<1> We haven't talked about logical expressions yet. But you know how '==' works.
<2> The function `is_atom()` can be used to check if something is an atom.
<3> The function `is_boolean()` can be used to check if something is a boolean.

[[elixir-introduction-logical-expressions]]
### Logical Expressions

A type `boolean` can store the values `true` and `false`. Together with `and`,
`or` and `not` those can create expressions:

[source,elixir]
----
iex(1)> true and true
true
iex(2)> false and false
false
iex(3)> true or false
true
iex(4)> not true
false
----
indexterm:["Logical Expressions"]

The operators `and`, `or` and `not` can only work with boolean values. The operators 
`&&` (and), `||` (or) and `!` (not) basically do the same but are a bit more free spirited and accept *truthy* and *falsy* values. We will get to that later if needed.

[[elixir-introduction-variables]]
### Variables
indexterm:["Variables"]

You already know how variables work from experiences in other programming
languages. Therefor we can dive right into it. Variable names follow the
[snake_case](https://en.wikipedia.org/wiki/Snake_case) format and start with a
lower case. Some examples:

[source,elixir]
----
iex(1)> length = 10 <1>
10
iex(2)> width = 23
23
iex(3)> area = length * width
230
----
<1> We use the operator `=` to bind the value 10 to the variable with the name `length`.

If you start a variable name with a capital error you'll get an error:

[source,elixir]
----
iex(4)> Radius = 2
** (MatchError) no match of right hand side value: 2 <1>
----
<1> Yes, `MatchError` is a rather strange error message here. It will make more
sense later. Binding values in variables is a bit more complicated than it seems
right now.

[[elixir-introduction-strings]]
### Strings
indexterm:["Strings"]

We already used a string in the <<elixir-introduction-hello-worlds,Hello World>> example. 
The use is for variables is straight forward:

[source,elixir]
----
iex(1)> first_name = "Stefan" <1>
"Stefan"
iex(2)> last_name = "Wintermeyer"
"Wintermeyer"
iex(3)> name = first_name <> " " <> last_name <2>
"Stefan Wintermeyer"
iex(4)> greeting = "Hello #{first_name}!" <3>
"Hello Stefan!"
iex(5)> counter = 23
23
iex(6)> "Count: #{counter}" <4>
"Count: 23"
----
<1> We assign the string "Stefan" to the variable with the name `first_name`.
<2> The `<>` operator can be used to concatinate strings.
indexterm:["<> operator"]
<3> `#{}` is Elixir's expressive string-interpolation. 
It can be used to inject a variable into a string which is encapsuled 
within double quotes.
<4> Elixir's expressive string-interpolation even works with integers. 
String-interpolation is done by the `Kernel.to_string/1` macro which evokes 
`String.Chars`. It can handle integers, floats, some lists (later more on lists) 
and atoms (later more on atoms) out of the box.
indexterm:["String-Interpolation"]

### Anonymous Functions
indexterm:["Functions", "Anonymous Functions"]

Functions are the method in a functional programming language to handle subprograms. 
Let me show you an example:

[source,elixir]
----
iex(1)> greeting = fn name -> "Hello #{name}!" end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> greeting.("Bob") <2>
"Hello Bob!"
iex(3)> greeting.("Alice")
"Hello Alice!"
iex(4)> square_area = fn(a) -> a * a end <3>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(5)> square_area.(10)
100
----
<1> We create a function and bind it to the variable `greeting`. 
* `fn` tells Elixir that you want to define a function.
* `name` is a parameter we can use to inject values.
* `->` is the operator to indicate the the following expression is the body of the function.
* `end` indicates the end of the function.
<2> We use the `.` (dot) operator to pass a value to the function.
<3> Feel free to use parentheses: `fn(a)`

These simple functions are called *anonymous functions*. They have no global 
name and must be bound to a variable.

Most times anonmous functions are simple one liners. But they don't have to be:

[source,elixir]
----
iex(1)> circular_area = fn radius -> 
...(1)>   pi = 3.14159265359
...(1)>   pi * radius * radius
...(1)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> circular_area.(3)
28.274333882310003
----

Sometimes it makes sense to create a function without an argument:

[source,elixir]
----
iex(1)> tomorrow = fn -> Date.add(Date.utc_today(), 1) end <1>
#Function<21.126501267/0 in :erl_eval.expr/5>
iex(2)> tomorrow.() <2>
~D[2020-05-07]
iex(3)> Date.utc_today() <3>
~D[2020-05-06]
iex(4)> tomorrow <4>
#Function<21.126501267/0 in :erl_eval.expr/5>
----
<1> Yes, we haven't discussed `Date.add` or `Date.utc_today()` yet. But you are smart enough to figure out what they do.
<2> Call the function `tomorrow` without a parameter.
<3> Just double check.
<4> Calling `tomorrow` without the `.` (dot) operator will not trigger the function.

Sometimes you need a function with multiple arguments. Those are seperated by commas:

[source,elixir]
----
iex(1)> area = fn a, b -> a * b end <1>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex(2)> area.(2,8)
16
iex(3)> volumne = fn a, b, c -> a * b * c end
#Function<19.126501267/3 in :erl_eval.expr/5>
iex(4)> volumne.(10,10,10) <2>
1000
----
<1> Two parameters (a and b).
<2> Three parameters (a, b and c).

NOTE: A function can not have more than 255 parameters. As a rule of thumb I suggest you never 
use more than 5 parameters. That is always an indicator that you should refactor your code.

#### Functions are First-Class Citizens

In Elixir a function is a value of the type `function`. So they are just like any 
other value. That means you can programm a function that expects an other function as 
a parameter.

It's hard to find a somehow meaningful example for this with our current Elixir
know-how. Germany has two kinds of value added taxes (VAT). The default is 19%
and the reduced one (e.g. for some foods) is 7%.

[source,elixir]
----
iex(1)> food_vat = fn price -> price * 0.07 end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> vat = fn price -> price * 0.19 end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> total_price = fn price, vat -> price + vat.(price) end <3>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex(4)> total_price.(10, food_vat) <4>
10.7   
iex(5)> total_price.(10, vat)
11.9
----
<1> This function calculates the 7% VAT.
<2> This function calculates the 19% VAT.
<3> This function calculates the total price which includes the tax. You see that the second parameter is a function.
<4> Example calculation which uses the `food_vat` function as the second parameter.

### The & operator
indexterm:["% operator"]

It is likely that you will stumble upon the `&` operator while searching
solutions for Elixir problems. It is a so called *capture operator*. It 
is a syntactical shortcut.

[source,elixir]
----
iex(1)> square_area = fn a -> a * a end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> square_area2 = &(&1 * &1) <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> square_area.(8)
64
iex(4)> square_area2.(9)
81
iex(5)> rectangle_area = &(&1 * &2) <3>
&:erlang.*/2
iex(6)> rectangle_area.(7,8)
56
----
<1> A normal anonymous function to calculate the area of a square.
<2> The same calculation but a different syntax. We use the & operator. No need for a `fn` and `end` with this operator.
<3> Multiple parameter can be used too (e.g. `&1`, `&2`).

Sometimes it is easier to read code which uses the `&` operator. Sometimes it is not.

### Variable Scopes
indexterm:["Scopes", "Variable Scopes"]

In every programming language variables have some sort of scope. Let's have a look 
into some code to figure out how variables in Elixr are scoped:

[source,elixir]
----
iex(1)> area = 5 <1>
5
iex(2)> IO.puts(area)
5
:ok
iex(3)> square_area = fn a -> <2>
...(3)>   area = a * a <3>
...(3)>   area
...(3)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(4)> square_area.(10) <4>
100
iex(5)> IO.puts(area) <5> 
5
:ok
----
<1> We bind the value of 5 to the variable `area`.
<2> We define an anonymous function.
<3> Within this function we bind the result of our calculation to an other variable `area`.
<4> Run the function with the parameter 10. That would mean that the `area` in the function gets set to the value 100.
<5> The original `area` hasn't changed a bit. Because it is in a different scope.

The `area` within the function is in an inner scope. The original `area` is in an outer scope.

But it gets a bit more complex:

[source,elixir]
----
iex(1)> pi = 3.14159265359 <1>
3.14159265359
iex(2)> circular_area = fn radius -> pi * radius * radius end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> circular_area.(10)
314.15926535899996
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We create an anonymous function which uses the variable `pi` to make the calculation.

So we can read the outer scope variable from within the function. So lets check if we can change it too:

[source,elixir]
----
iex(1)> pi = 3.14159265359 <1>
3.14159265359
iex(2)> circular_area = fn radius ->
...(2)>   pi = 3.14 <2>
...(2)>   pi * radius * radius
...(2)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> circular_area.(10) <3>
314.0
iex(4)> IO.puts(pi) <4>
3.14159265359
:ok
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We bind the inner scoped variable `pi` with the value 3.14.
<3> The 3.14 and not the 3.14159265359 gets used.
<4> The outer scoped `pi` is not changed.

NOTE: You can not change the value of an outer scoped variable but you can read
it. And you can create a new inner scope variable with the same name without
interacting with the outer scoped one.

### Functions and Modules
indexterm:["Modules", "Functions"]

Anonymous functions are useful but using just them to build a big software 
project would become messy very fast. We need a better way to structure our 
code. Let me introduce you to modules which include functions.

[source,elixir]
----
iex(1)> defmodule Store do <1>
...(1)>   def total_price(price, amount) do <2>
...(1)>     price * amount
...(1)>   end
...(1)> end
{:module, Store,
 <<70, 79, 82, 49, 0, 0, 5, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 133, 0,
   0, 0, 14, 12, 69, 108, 105, 120, 105, 114, 46, 83, 116, 111, 114, 101, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, ...>>, {:total_price, 2}}
iex(2)> Store.total_price(10,7) <3>
70
----
<1> `defmodule` is the keyword to define a module. The name of a modul starts with a capital letter.
<2> `def` is the keyword to define a function within a module.
<3> A function of a given module can be called from outside the module with this syntax.

`defmodule` and `def` use a `do ... end` construct to begin and end.

IMPORTANT: Moduel names use CamelCase which start with a capital letter. Function names use snake_case which start with a lower case letter.

Normaly a module contains more than one function:

[source,elixir]
----
iex(1)> defmodule Area do <1>
...(1)>   def rectangle(a, b) do <2>
...(1)>     a * b
...(1)>   end
...(1)> 
...(1)>   def square(a) do <3>
...(1)>     a * a
...(1)>   end
...(1)> end
{:module, Area,
 <<70, 79, 82, 49, 0, 0, 5, 156, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 137,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...>>, {:square, 1}}
iex(2)> Area.rectangle(4,5)
20
iex(3)> Area.square(4)
16
----
<1> We call this module 'Area'.
<2> The function rectangle/2 calculates the area of a rectangle.
<3> The function square/1 calculates the area of a square.

#### Private Functions
indexterm:["Private functions"]

Sometimes you want to define a function within a module without exposing it to the outside world. 
This can be done with a private functions which gets declared with `devp`:

[source,elixir]
----
iex(1)> defmodule Area do
...(1)>   def circle(radius) do
...(1)>     pi() * radius * radius
...(1)>   end
...(1)> 
...(1)>   defp pi do <1>
...(1)>     3.14
...(1)>   end
...(1)> end
{:module, Area,
 <<70, 79, 82, 49, 0, 0, 5, 104, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...>>, {:pi, 0}}
iex(2)> Area.circle(10) <2>
314.0
iex(3)> Area.pi <3>
** (UndefinedFunctionError) function Area.pi/0 is undefined or private
    Area.pi()
----
<1> The function `pi/0` is a private function.
<2> The function `circle/1` can be called from the outsite. It can use the private function `pi/0` from within the module.
<3> The function `pi/0` can not be called from the outsite.

#### Function Arity
indexterm:["Function Arity", "Arity"]

In the last couple of sentences you probably recognized the names of a functions
with the number of parameters following. `pi/0` let to `defp pi do` and
`circle/1` to `circle(radius)`. This number or arguments or parameters is called
**arity**. Arity is kind of a big thing in Elixir. Why? Because not just the
function name but also the arity defines a function. If we want to create a
module which calculates the area of rectangles it could look like this:

[source,elixir]
----
iex(1)> defmodule Rectangle do
...(1)>   def area(a) do <1>
...(1)>     a * a 
...(1)>   end
...(1)> 
...(1)>   def area(a, b) do <2>
...(1)>     a * b
...(1)>   end
...(1)> end
{:module, Rectangle,
 <<70, 79, 82, 49, 0, 0, 5, 108, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 16, 69, 108, 105, 120, 105, 114, 46, 82, 101, 99, 116, 97, 110,
   103, 108, 101, 8, 95, 95, 105, 110, 102, ...>>, {:area, 2}}
iex(2)> Rectangle.area(9) <3>
81
iex(3)> Rectangle.area(4,5) <4>
20
----
<1> The function ´area/1´ with the arity of 1 accepts one parameter.
<2> The function ´area/2´ with the arity of 2 accepts two parameters.
<3> So to calculate the area of a square you can call `area/1` with just one parameter.
<4> All non square rectangle areas have to be calculated with `area/2` which accepts two parameters.

#### Import
indexterm:["Import"]

We can call all functions by `ModuleName.function_name` but sometimes it would be nice 
to be able to just call that function by `function_name`. But Elixir has you covered. 
You can `import` a Module and have that:

[source,elixir]
----
iex(1)> defmodule Rectangle do
...(1)>   def area(a) do
...(1)>     a * a 
...(1)>   end
...(1)> 
...(1)>   def area(a, b) do
...(1)>     a * b
...(1)>   end
...(1)> end
{:module, Rectangle,
 <<70, 79, 82, 49, 0, 0, 5, 108, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 16, 69, 108, 105, 120, 105, 114, 46, 82, 101, 99, 116, 97, 110,
   103, 108, 101, 8, 95, 95, 105, 110, 102, ...>>, {:area, 2}}
iex(2)> import Rectangle <1>
Rectangle
iex(3)> area(5) <2>
25
----
<1> Here we `import Rectangle` to have all the functions of that module at our fingertips.
<2> No need to `Rectangle.area/1` any more `area/1` is just fine.

And you can also just import special functions from that module:

[source,elixir]
----
iex(3)> import Rectangle, only: [area: 2] <1>
Rectangle
iex(4)> area(1) <2>
** (CompileError) iex:7: undefined function area/1

iex(7)> area(1,5) <3>
5
----
<1> Let's just import `area/2` but not all the other functions of that module.
<2> I try to run `area/1` but that throughts an error because I didn't import it.
<3> Just works fine.

NOTE: When ever you just use a given function without a module name before 
that module has already been imported by Elixir (e.g. the `Kernel` modul gets 
imported automatically).

### Lists and Tuples
indexterm:["Lists and Tuples"]

Lists and tuples are used to store multiple elements in a sort of list. Both
look alike but are quite different performance wise. 

* Tuples are fast when you have to access it's data but slow when you want to
  change it's data. They are stored contiguously in memory. Accessing one
  element of a tuple or getting the size of it is fast and always takes the same
  amount of time.
* Lists are stored as linked lists in memory. One element holds it's own value
  and a link to the next element. Accessing single elements and the length of a
  lists is a linear operation which takes more time. The longer the list the
  more time it takes. But it is fast to add a new element to the end of a list.

NOTE: Right now you don't need to loose sleep over the decision which one to
use. Over the course of the book you'll get a feeling which one is best suited
for what problem.

#### Lists
indexterm:["Lists"]

List store multiple values or different types.
A list is encapsuled in `[]`:

[source,elixir]
----
iex(1)> [1, 2, 3, 4]
[1, 2, 3, 4]
iex(2)> ["a", "b", "c"]
["a", "b", "c"]
iex(3)> [1, "b", true, false, :blue, "house"]
[1, "b", true, false, :blue, "house"]
iex(4)>
----

The operators `++` and `--` can be used to concatenate and substract lists from each other:

[source,elixir]
----
iex(1)> [1, 2] ++ [2, 4] <1>
[1, 2, 2, 4]
iex(2)> [1, 2] ++ [1] <2>
[1, 2, 1]
iex(3)> [1, "a", 2, false, true] -- ["a", 2] <3>
[1, false, true]
----
<1> Makes totally sense.
<2> So does this.
<3> A bit trickier. The second and third element of the first list get substracted.

##### Head and Tail of Lists
indexterm:["Head", "Tail", "hd/1", "tl/1"]

A lot of times Elixir developers want to work with the head and tail of a list. Head 
is the first element (counting from the left side) and the tail is the rest. There 
are too functions for that:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"] <1>
["apple", "orange", "banana", "pineapple"]
iex(2)> hd(shopping_list) <2>
"apple"
iex(3)> tl(shopping_list) <3>
["orange", "banana", "pineapple"]
iex(4)> shopping_list <4>
["apple", "orange", "banana", "pineapple"]
----
<1> We define a list and bind it to the variable `shopping_list`.
<2> `hd/1` fetches the first element of the list.
<3> `tl/1` fetches the rest of the list.
<4> The `shopping_list` itself hasn't changed.

Let's see what happens with empty lists or lists which just have one element:

[source,elixir]
----
iex(6)> hd([]) <1>
** (ArgumentError) argument error
    :erlang.hd([])
iex(6)> tl([]) <2>
** (ArgumentError) argument error
    :erlang.tl([])
iex(6)> hd(["grapefruit"]) <3>
"grapefruit"
iex(7)> tl(["grapefruit"]) <4>
[]
----
<1> You can't get the head of an empty list.
<2> And there is no tail of an empty list.
<3> There is a head of a list with one element.
<4> The tail of a list with one element is an empty list.

##### length/1
indexterm:["length/1"]

The function `length/1` tells how many elements a list contains:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)> length(shopping_list)
4
iex(3)> length([1, 2])
2
iex(4)> length([])
0
----

#### Tuples
indexterm:["Tuples"]

Like Lists tuples can hold multiple elements of different types. The 
elements are encapsuled with '{}':

[source,elixir]
----
iex(1)> {1, 2, 3} <1>
{1, 2, 3}
iex(2)> {:ok, "test"} <2>
{:ok, "test"}
iex(3)> {true, :apple, 234, "house", 3.14} <3>
{true, :apple, 234, "house", 3.14}
----
<1> A tuple which contains three integers. 
<2> A tuple which contains one atom which represents a status and one string. 
Is is actually something very common in Elixir. You will see that a lot. 
<3> A tuple with a mix of all sorts of values.

We don't use the head and tail idea with tuples. But we can access every element
of a tuple with an index:

[source,elixir]
----
iex(1)> result = {:ok, "Lorem ipsum"}   
{:ok, "Lorem ipsum"}
iex(2)> elem(result, 1) <1>
"Lorem ipsum"
iex(3)> elem(result, 0) <2>
:ok
----
<1> The function `elem/2` gives us a fast access to each element of a tuple.
<2> The count starts with 0 for the first element.

##### Tuple Functions
indexterm:["Tuple functions"]

The following functions are useful when you handle data with tuples:

* `Tuple.append/2` adds an element to a tuple.
indexterm:["append/2", "Tuple.append/2"]
* `Tuple.delete_at/2` deletes an element of a tuple.
indexterm:["delete_at/2", "Tuple.delete_at/2"]
* `Tuple.insert_at/3` adds an element at a specific position.
indexterm:["insert_at/3", "Tuple.insert_at/3"]
* `Tuple.to_list/1` converts a tuple to a list.
indexterm:["to_list/1", "Tuple.to_list/1"]
* `Tuple.size/1` returns the number of elements of the tuple.

Examples:

[source,elixir]
----
iex(1)> results = {:ok, "Lorem ipsum"}
{:ok, "Lorem ipsum"}
iex(2)> b = Tuple.append(results, "Test")
{:ok, "Lorem ipsum", "Test"}
iex(3)> c = Tuple.delete_at(b, 1)
{:ok, "Test"}
iex(4)> d = Tuple.insert_at(b, 1, "ipsum")
{:ok, "ipsum", "Lorem ipsum", "Test"}
iex(5)> new_list = Tuple.to_list(d)
[:ok, "ipsum", "Lorem ipsum", "Test"]
iex(6)> tuple_size(d)
4
----

### Pattern Matching

