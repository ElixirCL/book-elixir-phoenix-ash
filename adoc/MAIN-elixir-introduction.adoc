[[elixir_introduction]]
## Elixir Introduction

This chapter will teach you the absolut basics of Elixir. Just enough to become
productive with Phoenix. There is a lot more to learn and to understand about
Elixir.

Buckle up. It is going to be a bumpy and sometimes boring ride. It's tough to
teach all the needed Elixir knowledge in just one chapter.

NOTE: All code examples are tested with Elixir version 10.2.

[[elixir-introduction-iex]]
### Elixir's Interactive Shell (iex)

Your Elixir installation comes with an Elixir's Interactive Shell (`iex`) which we 
will use for most examples in this chapter. Please go to your command line and 
fire it up:
indexterm:["iex", "Elixir's Interactive Shell"]

[source,elixir]
----
$ iex 
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> <1>
----
<1> This is your iex prompt.

IMPORTANT: You have to press `CTRL-C` twice(!) to stop the `iex`.

The `iex` will be your trusted friend during the work with this book and later
while working with Phoenix. While programming in development mode you can use it 
to dive into the core of your Phoenix application. You can do so too while 
being in production mode but that is the equivalent to an open heard surgery. It can 
be a life saver but you really need to know what you are doing.

TIP: The iex offers autocomplete when possible. So when in doubt press `TAB`.

TIP: The iex offers a history too. To recycle the last command just press on the arrow-up key.

#### Help in the iex

The iex has a build in help function `h/1` which gives you access to some 
basic documentation: 

[source,elixir]
----
iex(2)> h length/1

                                def length(list)                                

  @spec length(list()) :: non_neg_integer()

guard: true

Returns the length of list.

Allowed in guard tests. Inlined by the compiler.

## Examples

    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])
    9
----

#### Run the code examples not in iex

If you prefer to run all code examples not in the `iex` you can do so. Just put
them in a file with the ending `.exs` and call that file from the command file
with `elixir example.exs`.

When tackling deployment I'll discuss how to compile the code.
`elixir example.exs` does not compile it.

[[elixir-introduction-hello-world]]
### Hello world!

The classic! But never the less very important. You can use the function
`IO.puts()` to print a string to standard output:

[source,elixir]
----
iex(1)> IO.puts("Hello world!")
Hello world!
:ok
----
indexterm:["Hello World!"]

Strings are always encapsuled within double quotes. In case you need to have 
double quotes within a string you have to escape them with backslashes:

[source,elixir]
----
iex(2)> IO.puts("With double quotes: \"Hello world!\"")
With double quotes: "Hello world!"
:ok
iex(3)>
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C<1>
----
<1> Don't be afraid of the `BREAK` menue. With the first `Ctrl+C` the `iex`
displays this list of choices (the `BREAK` menu) and with the second `Ctrl+C`
you end the `iex`.
indexterm:["BREAK menue"]

[[elixir-introduction-basic-calculations]]
### Basic Calculations

We can use the types `integer` (Integer numbers) and `float` (Real numbers) to
do all sorts of calcuations. We can use the usual operators. I'll show you a
couple of examples:

[source,elixir]
----
$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 1 + 1
2
iex(2)> 1.1 + 1
2.1
iex(3)> 2 - 1
1
iex(4)> 10 * 1000000000000000
10000000000000000
iex(5)> 23 / 3
7.666666666666667
iex(6)> 
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C
----

NOTE: If it's OK with you I'll skip the `iex` and the `BREAK` part in the rest
of this chapter. By that we get more real estate for the essential stuff and less trees 
have to die to get the book version printed.

[[elixir-introduction-atoms]]
### Atoms

An atom just consists of it's own name. In some other programming languages they 
are called symbols. Atoms start with a `:`

[source,elixir]
----
iex(1)> :red
:red
iex(2)> :blue
:blue
----

NOTE: Atom names can be written in snake_case or in CamelCase. But the usual Elixir 
convention is to use snake_case.

#### Booleans are atoms too

Booleans are a good example for the use of atoms. But they are special because 
you don't have to prefix them with a `:`.

[source,elixir]
----
iex(1)> false == :false <1>
true
iex(2)> is_atom(false) <2>
true
iex(3)> is_boolean(:false) <3>
true
----
<1> We haven't talked about logical expressions yet. But you know how '==' works.
<2> The function `is_atom()` can be used to check if something is an atom.
<3> The function `is_boolean()` can be used to check if something is a boolean.

[[elixir-introduction-logical-expressions]]
### Logical Expressions

A type `boolean` can store the values `true` and `false`. Together with `and`,
`or` and `not` those can create expressions:

[source,elixir]
----
iex(1)> true and true
true
iex(2)> false and false
false
iex(3)> true or false
true
iex(4)> not true
false
----
indexterm:["Logical Expressions"]

The operators `and`, `or` and `not` can only work with boolean values. The operators 
`&&` (and), `||` (or) and `!` (not) basically do the same but are a bit more free spirited and accept *truthy* and *falsy* values. We will get to that later if needed.

[[elixir-introduction-variables]]
### Variables
indexterm:["Variables"]

You already know how variables work from experiences in other programming
languages. Therefor we can dive right into it. Variable names follow the
[snake_case](https://en.wikipedia.org/wiki/Snake_case) format and start with a
lower case. Some examples:

[source,elixir]
----
iex(1)> length = 10 <1>
10
iex(2)> width = 23
23
iex(3)> area = length * width
230
----
<1> We use the operator `=` to bind the value 10 to the variable with the name `length`.

If you start a variable name with a capital error you'll get an error:

[source,elixir]
----
iex(4)> Radius = 2
** (MatchError) no match of right hand side value: 2 <1>
----
<1> Yes, `MatchError` is a rather strange error message here. It will make more
sense later. Binding values in variables is a bit more complicated than it seems
right now.

[[elixir-introduction-strings]]
### Strings
indexterm:["Strings"]

We already used a string in the <<elixir-introduction-hello-world,Hello World>> example. 
The use is for variables is straight forward:

[source,elixir]
----
iex(1)> first_name = "Stefan" <1>
"Stefan"
iex(2)> last_name = "Wintermeyer"
"Wintermeyer"
iex(3)> name = first_name <> " " <> last_name <2>
"Stefan Wintermeyer"
iex(4)> greeting = "Hello #{first_name}!" <3>
"Hello Stefan!"
iex(5)> counter = 23
23
iex(6)> "Count: #{counter}" <4>
"Count: 23"
----
<1> We assign the string "Stefan" to the variable with the name `first_name`.
<2> The `<>` operator can be used to concatinate strings.
indexterm:["<> operator"]
<3> `#{}` is Elixir's expressive string-interpolation. 
It can be used to inject a variable into a string which is encapsuled 
within double quotes.
<4> Elixir's expressive string-interpolation even works with integers. 
String-interpolation is done by the `Kernel.to_string/1` macro which evokes 
`String.Chars`. It can handle integers, floats, some lists (later more on lists) 
and atoms (later more on atoms) out of the box.
indexterm:["String-Interpolation"]

### Anonymous Functions
indexterm:["Functions", "Anonymous Functions"]

Functions are the method in a functional programming language to handle subprograms. 
Let me show you an example:

[source,elixir]
----
iex(1)> greeting = fn name -> "Hello #{name}!" end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> greeting.("Bob") <2>
"Hello Bob!"
iex(3)> greeting.("Alice")
"Hello Alice!"
iex(4)> square_area = fn(a) -> a * a end <3>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(5)> square_area.(10)
100
----
<1> We create a function and bind it to the variable `greeting`. 
* `fn` tells Elixir that you want to define a function.
* `name` is a parameter we can use to inject values.
* `->` is the operator to indicate the the following expression is the body of the function.
* `end` indicates the end of the function.
<2> We use the `.` (dot) operator to pass a value to the function.
<3> Feel free to use parentheses: `fn(a)`

These simple functions are called *anonymous functions*. They have no global 
name and must be bound to a variable.

Most times anonmous functions are simple one liners. But they don't have to be:

[source,elixir]
----
iex(1)> circular_area = fn radius -> 
...(1)>   pi = 3.14159265359
...(1)>   pi * radius * radius
...(1)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> circular_area.(3)
28.274333882310003
----

Sometimes it makes sense to create a function without an argument:

[source,elixir]
----
iex(1)> tomorrow = fn -> Date.add(Date.utc_today(), 1) end <1>
#Function<21.126501267/0 in :erl_eval.expr/5>
iex(2)> tomorrow.() <2>
~D[2020-05-07]
iex(3)> Date.utc_today() <3>
~D[2020-05-06]
iex(4)> tomorrow <4>
#Function<21.126501267/0 in :erl_eval.expr/5>
----
<1> Yes, we haven't discussed `Date.add` or `Date.utc_today()` yet. But you are smart enough to figure out what they do.
<2> Call the function `tomorrow` without a parameter.
<3> Just double check.
<4> Calling `tomorrow` without the `.` (dot) operator will not trigger the function.

Sometimes you need a function with multiple arguments. Those are seperated by commas:

[source,elixir]
----
iex(1)> area = fn a, b -> a * b end <1>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex(2)> area.(2,8)
16
iex(3)> volumne = fn a, b, c -> a * b * c end
#Function<19.126501267/3 in :erl_eval.expr/5>
iex(4)> volumne.(10,10,10) <2>
1000
----
<1> Two parameters (a and b).
<2> Three parameters (a, b and c).

NOTE: A function can not have more than 255 parameters. As a rule of thumb I suggest you never 
use more than 5 parameters. That is always an indicator that you should refactor your code.

#### Functions are First-Class Citizens

In Elixir a function is a value of the type `function`. So they are just like any 
other value. That means you can programm a function that expects an other function as 
a parameter.

It's hard to find a somehow meaningful example for this with our current Elixir
know-how. Germany has two kinds of value added taxes (VAT). The default is 19%
and the reduced one (e.g. for some foods) is 7%.

[source,elixir]
----
iex(1)> food_vat = fn price -> price * 0.07 end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> vat = fn price -> price * 0.19 end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> total_price = fn price, vat -> price + vat.(price) end <3>
#Function<13.126501267/2 in :erl_eval.expr/5>
iex(4)> total_price.(10, food_vat) <4>
10.7   
iex(5)> total_price.(10, vat)
11.9
----
<1> This function calculates the 7% VAT.
<2> This function calculates the 19% VAT.
<3> This function calculates the total price which includes the tax. You see that the second parameter is a function.
<4> Example calculation which uses the `food_vat` function as the second parameter.

### The & operator
indexterm:["% operator"]

It is likely that you will stumble upon the `&` operator while searching
solutions for Elixir problems. It is a so called *capture operator*. It 
is a syntactical shortcut.

[source,elixir]
----
iex(1)> square_area = fn a -> a * a end <1>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(2)> square_area2 = &(&1 * &1) <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> square_area.(8)
64
iex(4)> square_area2.(9)
81
iex(5)> rectangle_area = &(&1 * &2) <3>
&:erlang.*/2
iex(6)> rectangle_area.(7,8)
56
----
<1> A normal anonymous function to calculate the area of a square.
<2> The same calculation but a different syntax. We use the & operator. No need for a `fn` and `end` with this operator.
<3> Multiple parameter can be used too (e.g. `&1`, `&2`).

Sometimes it is easier to read code which uses the `&` operator. Sometimes it is not.

### Variable Scopes
indexterm:["Scopes", "Variable Scopes"]

In every programming language variables have some sort of scope. Let's have a look 
into some code to figure out how variables in Elixr are scoped:

[source,elixir]
----
iex(1)> area = 5 <1>
5
iex(2)> IO.puts(area)
5
:ok
iex(3)> square_area = fn a -> <2>
...(3)>   area = a * a <3>
...(3)>   area
...(3)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(4)> square_area.(10) <4>
100
iex(5)> IO.puts(area) <5> 
5
:ok
----
<1> We bind the value of 5 to the variable `area`.
<2> We define an anonymous function.
<3> Within this function we bind the result of our calculation to an other variable `area`.
<4> Run the function with the parameter 10. That would mean that the `area` in the function gets set to the value 100.
<5> The original `area` hasn't changed a bit. Because it is in a different scope.

The `area` within the function is in an inner scope. The original `area` is in an outer scope.

But it gets a bit more complex:

[source,elixir]
----
iex(1)> pi = 3.14159265359 <1>
3.14159265359
iex(2)> circular_area = fn radius -> pi * radius * radius end <2>
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> circular_area.(10)
314.15926535899996
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We create an anonymous function which uses the variable `pi` to make the calculation.

So we can read the outer scope variable from within the function. So lets check if we can change it too:

[source,elixir]
----
iex(1)> pi = 3.14159265359 <1>
3.14159265359
iex(2)> circular_area = fn radius ->
...(2)>   pi = 3.14 <2>
...(2)>   pi * radius * radius
...(2)> end
#Function<7.126501267/1 in :erl_eval.expr/5>
iex(3)> circular_area.(10) <3>
314.0
iex(4)> IO.puts(pi) <4>
3.14159265359
:ok
----
<1> We bind the value 3.14159265359 to the variable with the name `pi`.
<2> We bind the inner scoped variable `pi` with the value 3.14.
<3> The 3.14 and not the 3.14159265359 gets used.
<4> The outer scoped `pi` is not changed.

NOTE: You can not change the value of an outer scoped variable but you can read
it. And you can create a new inner scope variable with the same name without
interacting with the outer scoped one.

### Functions and Modules
indexterm:["Modules", "Functions"]

Anonymous functions are useful but using just them to build a big software
project would become messy very fast. We need a better way to structure our
code. Let me introduce you to Modules which are used to organize a collection of
functions.

[source,elixir]
----
iex(1)> defmodule Store do <1>
...(1)>   def total_price(price, amount) do <2>
...(1)>     price * amount
...(1)>   end
...(1)> end
{:module, Store,
 <<70, 79, 82, 49, 0, 0, 5, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 133, 0,
   0, 0, 14, 12, 69, 108, 105, 120, 105, 114, 46, 83, 116, 111, 114, 101, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, ...>>, {:total_price, 2}}
iex(2)> Store.total_price(10,7) <3>
70
----
<1> `defmodule` is the keyword to define a module. The name of a modul starts with a capital letter.
<2> `def` is the keyword to define a function within a module.
<3> A function of a given module can be called from outside the module with this syntax.

`defmodule` and `def` use a `do ... end` construct to begin and end.

IMPORTANT: Moduel names use CamelCase which start with a capital letter. Function names use snake_case which start with a lower case letter.

Normaly a module contains more than one function:

[source,elixir]
----
iex(1)> defmodule Area do <1>
...(1)>   def rectangle(a, b) do <2>
...(1)>     a * b
...(1)>   end
...(1)> 
...(1)>   def square(a) do <3>
...(1)>     a * a
...(1)>   end
...(1)> end
{:module, Area,
 <<70, 79, 82, 49, 0, 0, 5, 156, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 137,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...>>, {:square, 1}}
iex(2)> Area.rectangle(4,5)
20
iex(3)> Area.square(4)
16
----
<1> We call this module 'Area'.
<2> The function rectangle/2 calculates the area of a rectangle.
<3> The function square/1 calculates the area of a square.

#### Private Functions
indexterm:["Private functions"]

Sometimes you want to define a function within a module without exposing it to the outside world. 
This can be done with a private functions which gets declared with `devp`:

[source,elixir]
----
iex(1)> defmodule Area do
...(1)>   def circle(radius) do
...(1)>     pi() * radius * radius
...(1)>   end
...(1)> 
...(1)>   defp pi do <1>
...(1)>     3.14
...(1)>   end
...(1)> end
{:module, Area,
 <<70, 79, 82, 49, 0, 0, 5, 104, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...>>, {:pi, 0}}
iex(2)> Area.circle(10) <2>
314.0
iex(3)> Area.pi <3>
** (UndefinedFunctionError) function Area.pi/0 is undefined or private
    Area.pi()
----
<1> The function `pi/0` is a private function.
<2> The function `circle/1` can be called from the outsite. It can use the private function `pi/0` from within the module.
<3> The function `pi/0` can not be called from the outsite.

#### Function Arity
indexterm:["Function Arity", "Arity"]

In the last couple of sentences you probably recognized the names of a functions
with the number of parameters following. `pi/0` let to `defp pi do` and
`circle/1` to `circle(radius)`. This number or arguments or parameters is called
**arity**. Arity is kind of a big thing in Elixir. Why? Because not just the
function name but also the arity defines a function. If we want to create a
module which calculates the area of rectangles it could look like this:

[source,elixir]
----
iex(1)> defmodule Rectangle do
...(1)>   def area(a) do <1>
...(1)>     a * a 
...(1)>   end
...(1)> 
...(1)>   def area(a, b) do <2>
...(1)>     a * b
...(1)>   end
...(1)> end
{:module, Rectangle,
 <<70, 79, 82, 49, 0, 0, 5, 108, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 16, 69, 108, 105, 120, 105, 114, 46, 82, 101, 99, 116, 97, 110,
   103, 108, 101, 8, 95, 95, 105, 110, 102, ...>>, {:area, 2}}
iex(2)> Rectangle.area(9) <3>
81
iex(3)> Rectangle.area(4,5) <4>
20
----
<1> The function ´area/1´ with the arity of 1 accepts one parameter.
<2> The function ´area/2´ with the arity of 2 accepts two parameters.
<3> So to calculate the area of a square you can call `area/1` with just one parameter.
<4> All non square rectangle areas have to be calculated with `area/2` which accepts two parameters.

#### Hierachical Modules

In a big project you will have multiple layers of Module namespaces to keep everything in 
some sort of structure.

This can be done by adding `.` between the Module names:

[source,elixir]
----
iex(1)> defmodule Calculator.Area do
...(1)>   def square(a) do
...(1)>     a * a
...(1)>   end
...(1)> end
{:module, Calculator.Area,
 <<70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 46, 65, 114, 101, 97, ...>>, {:square, 1}}
iex(2)> Calculator.Area.square(5)
25
----

It is just a shortcut. You could also nest the Modules:

[source,elixir]
----
iex(1)> defmodule Calculator do
...(1)>   defmodule Area do
...(1)>     def square(a) do
...(1)>       a * a
...(1)>     end
...(1)>   end
...(1)> end
{:module, Calculator,
 <<70, 79, 82, 49, 0, 0, 3, 164, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 124,
   0, 0, 0, 12, 17, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 8, 95, 95, 105, 110, ...>>,
 {:module, Calculator.Area,
  <<70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
    0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
    97, 116, 111, 114, 46, ...>>, {:square, 1}}}
iex(2)> Calculator.Area.square(5)
25
----

#### Import
indexterm:["Import", "Import Modules"]

We can import access to public functions from other modules. So that we don't 
have to use their fully qualified name.

[source,elixir]
----
iex(1)> defmodule Rectangle do
...(1)>   def area(a) do
...(1)>     a * a 
...(1)>   end
...(1)> 
...(1)>   def area(a, b) do
...(1)>     a * b
...(1)>   end
...(1)> end
{:module, Rectangle,
 <<70, 79, 82, 49, 0, 0, 5, 108, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 16, 69, 108, 105, 120, 105, 114, 46, 82, 101, 99, 116, 97, 110,
   103, 108, 101, 8, 95, 95, 105, 110, 102, ...>>, {:area, 2}}
iex(2)> import Rectangle <1>
Rectangle
iex(3)> area(5) <2>
25
----
<1> Here we `import Rectangle` to have all the functions of that module at our fingertips.
<2> No need to `Rectangle.area/1` any more `area/1` is just fine.

And you can also just import special functions from that module:

[source,elixir]
----
iex(3)> import Rectangle, only: [area: 2] <1>
Rectangle
iex(4)> area(1) <2>
** (CompileError) iex:7: undefined function area/1

iex(7)> area(1,5) <3>
5
----
<1> Let's just import `area/2` but not all the other functions of that module.
<2> I try to run `area/1` but that throughts an error because I didn't import it.
<3> Just works fine.

NOTE: When ever you just use a given function without a module name before 
that module has already been imported by Elixir (e.g. the `Kernel` modul gets 
imported automatically).

##### Import Hierarchical Modules

Often your want to import hierachical modules. Here's how:

[source,elixir]
----
iex(1)> defmodule Calculator.Area do
...(1)>   def square(a) do
...(1)>     a * a
...(1)>   end
...(1)> end
{:module, Calculator.Area,
 <<70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 46, 65, 114, 101, 97, ...>>, {:square, 1}}
iex(2)> import Calculator.Area
Calculator.Area
iex(3)> square(5)     
25
----

#### Alias
indexterm:["Alias"]

`alias` offers the possiblity to set an alias to a module name.

[source,elixir]
----
iex(1)> defmodule Calculator.Area do
...(1)>   def square(a) do
...(1)>     a * a
...(1)>   end
...(1)> end
{:module, Calculator.Area,
 <<70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 46, 65, 114, 101, 97, ...>>, {:square, 1}}
iex(2)> alias Calculator.Area, as: Area <1>
Calculator.Area
iex(3)> Area.square(99)
9801
iex(4)> alias Calculator.Area <2>      
Calculator.Area
iex(5)> Area.square(99)      
9801
----
<1> Set an alias for `Calculator.Area` as `Area`.
<2> A shortcurt for that specific case. Same result but less to type.

#### The Pipe Operator (|>)
indexterm:["Pipe Operator", "|>"]

Quite often one wants to use a couple of different functions in a row. 
Let's assume you want to reverse a string and capitalize it afterwards. 
Here's the code to do that:

[source,elixir]
----
iex(1)> String.reverse("house") <1>
"esuoh"
iex(2)> String.capitalize("esuoh") <2>
"Esuoh"
iex(3)> String.capitalize(String.reverse("house")) <3>
"Esuoh"
----
<1> `String.reverse/1` reverses the string.
<2> `String.capitalize/1` capitalizes all the letters in a string.
<3>  Connect the two functions.

The problem with `String.capitalize(String.reverse("house"))` is the 
lack of readability. It kind of works with just two functions but 
what about one or two more functions in that line? Here comes the 
pipe operator for the rescue. It is a piece of syntax sugar. Have 
a look:

[source,elixir]
----
iex(4)> String.reverse("house") |> String.capitalize <1>
"Esuoh"
----
<1> The pipe operator `|>` takes the result of the first function 
and puts it as the first parameter of the following function.

Of course you can use multiple pipe operators:

[source,elixir]
----
iex(5)> String.reverse("house") |> String.capitalize |> String.downcase
"esuoh"
----

The pipe operator is just a way to make code more readable.

### Lists and Tuples
indexterm:["Lists and Tuples"]

Lists and tuples are used to store multiple elements in a sort of list. Both
look alike but are quite different performance wise. 

* Tuples are fast when you have to access it's data but slow when you want to
  change it's data. They are stored contiguously in memory. Accessing one
  element of a tuple or getting the size of it is fast and always takes the same
  amount of time.
* Lists are stored as linked lists in memory. One element holds it's own value
  and a link to the next element. Accessing single elements and the length of a
  lists is a linear operation which takes more time. The longer the list the
  more time it takes. But it is fast to add a new element to the end of a list.

NOTE: Right now you don't need to loose sleep over the decision which one to
use. Over the course of the book you'll get a feeling which one is best suited
for what problem.

#### Lists
indexterm:["Lists"]

List store multiple values or different types.
A list is encapsuled in `[]`:

[source,elixir]
----
iex(1)> [1, 2, 3, 4]
[1, 2, 3, 4]
iex(2)> ["a", "b", "c"]
["a", "b", "c"]
iex(3)> [1, "b", true, false, :blue, "house"]
[1, "b", true, false, :blue, "house"]
iex(4)>
----

The operators `++` and `--` can be used to concatenate and substract lists from each other:

[source,elixir]
----
iex(1)> [1, 2] ++ [2, 4] <1>
[1, 2, 2, 4]
iex(2)> [1, 2] ++ [1] <2>
[1, 2, 1]
iex(3)> [1, "a", 2, false, true] -- ["a", 2] <3>
[1, false, true]
----
<1> Makes totally sense.
<2> So does this.
<3> A bit trickier. The second and third element of the first list get substracted.

##### Head and Tail of Lists
indexterm:["Head", "Tail", "hd/1", "tl/1"]

A lot of times Elixir developers want to work with the head and tail of a list. Head 
is the first element (counting from the left side) and the tail is the rest. There 
are too functions for that:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"] <1>
["apple", "orange", "banana", "pineapple"]
iex(2)> hd(shopping_list) <2>
"apple"
iex(3)> tl(shopping_list) <3>
["orange", "banana", "pineapple"]
iex(4)> shopping_list <4>
["apple", "orange", "banana", "pineapple"]
----
<1> We define a list and bind it to the variable `shopping_list`.
<2> `hd/1` fetches the first element of the list.
<3> `tl/1` fetches the rest of the list.
<4> The `shopping_list` itself hasn't changed.

Let's see what happens with empty lists or lists which just have one element:

[source,elixir]
----
iex(6)> hd([]) <1>
** (ArgumentError) argument error
    :erlang.hd([])
iex(6)> tl([]) <2>
** (ArgumentError) argument error
    :erlang.tl([])
iex(6)> hd(["grapefruit"]) <3>
"grapefruit"
iex(7)> tl(["grapefruit"]) <4>
[]
----
<1> You can't get the head of an empty list.
<2> And there is no tail of an empty list.
<3> There is a head of a list with one element.
<4> The tail of a list with one element is an empty list.

##### length/1
indexterm:["length/1"]

The function `length/1` tells how many elements a list contains:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)> length(shopping_list)
4
iex(3)> length([1, 2])
2
iex(4)> length([])
0
----

#### Tuples
indexterm:["Tuples"]

Like Lists tuples can hold multiple elements of different types. The 
elements are encapsuled with '{}':

[source,elixir]
----
iex(1)> {1, 2, 3} <1>
{1, 2, 3}
iex(2)> {:ok, "test"} <2>
{:ok, "test"}
iex(3)> {true, :apple, 234, "house", 3.14} <3>
{true, :apple, 234, "house", 3.14}
----
<1> A tuple which contains three integers. 
<2> A tuple which contains one atom which represents a status and one string. 
Is is actually something very common in Elixir. You will see that a lot. 
<3> A tuple with a mix of all sorts of values.

We don't use the head and tail idea with tuples. But we can access every element
of a tuple with an index:

[source,elixir]
----
iex(1)> result = {:ok, "Lorem ipsum"}   
{:ok, "Lorem ipsum"}
iex(2)> elem(result, 1) <1>
"Lorem ipsum"
iex(3)> elem(result, 0) <2>
:ok
----
<1> The function `elem/2` gives us a fast access to each element of a tuple.
<2> The count starts with 0 for the first element.

##### Tuple Functions
indexterm:["Tuple functions"]

The following functions are useful when you handle data with tuples:

* `Tuple.append/2` adds an element to a tuple.
indexterm:["append/2", "Tuple.append/2"]
* `Tuple.delete_at/2` deletes an element of a tuple.
indexterm:["delete_at/2", "Tuple.delete_at/2"]
* `Tuple.insert_at/3` adds an element at a specific position.
indexterm:["insert_at/3", "Tuple.insert_at/3"]
* `Tuple.to_list/1` converts a tuple to a list.
indexterm:["to_list/1", "Tuple.to_list/1"]
* `Tuple.size/1` returns the number of elements of the tuple.

Examples:

[source,elixir]
----
iex(1)> results = {:ok, "Lorem ipsum"}
{:ok, "Lorem ipsum"}
iex(2)> b = Tuple.append(results, "Test")
{:ok, "Lorem ipsum", "Test"}
iex(3)> c = Tuple.delete_at(b, 1)
{:ok, "Test"}
iex(4)> d = Tuple.insert_at(b, 1, "ipsum")
{:ok, "ipsum", "Lorem ipsum", "Test"}
iex(5)> new_list = Tuple.to_list(d)
[:ok, "ipsum", "Lorem ipsum", "Test"]
iex(6)> tuple_size(d)
4
----

### Maps and Structs

List and Tuples don't provide a functionality to access values with a key. 
That can be achieved with Maps and Structs.

#### Maps
indexterm:["Map"]

Maps provide a way to store and retrieve key-value pairs. A Map is created 
with a `%{}` syntax. 

[source,elixir]
----
iex(1)> product_prices = %{"Apple" => 0.5, "Orange" => 0.7} <1>
%{"Apple" => 0.5, "Orange" => 0.7}
iex(2)> Map.get(product_prices, "Orange") <2>
0.7
iex(3)> Map.get(product_prices, "Banana") <3>
nil
iex(4)> Map.has_key?(product_prices, "Banana") <4>
false
----
<1> We create a new map and bind it to the variable `product_prices`.
<2> `Map.get/2` gets a value to a given key.
<3> `Map.get/2` returns nil if a given key doesn't exist.
<4> If you need to check if a key exists you can do it with `Map.hay_key?/2`

But keys don't have to be a specific type. Everything can be a key and a value:

[source,elixir]
----
iex(1)> %{"one" => 1, "two" => "abc", 3 => 7, true => "asdf"} <1>
%{3 => 7, true => "asdf", "one" => 1, "two" => "abc"}
iex(2)> %{"one" => 1, true => "asdf", true => "z"} <2>               
warning: key true will be overridden in map
  iex:2

%{true => "z", "one" => 1}
----
<1> A mixed bag of different types. Feel free to go wild.
<2> A key has to be unique within a Map. The last one will be the winner.

##### Atom keys

Using Atoms as keys in Maps gives you access to some nifty features:

[source,elixir]
----
iex(1)> product_prices = %{apple: 0.5, orange: 0.7} <1>
%{apple: 0.5, orange: 0.7}
iex(2)> product_prices.apple <2>
0.5
iex(3)> product_prices.banana <3>
** (KeyError) key :banana not found in: %{apple: 0.5, orange: 0.7}
----
<1> With Atoms as keys you can use this syntax which is a bit easier to read and less work to type.
<2> Again, this syntax is easier to work with but only works for Atom keys.
<3> Just checking what happens if the key doesn't exist in the Map.

##### Map Functions

The Map module offers a bunch of useful functions. For a complete list have a 
look at https://hexdocs.pm/elixir/Map.html

Here are just a couple of examples:

[source,elixir]
----
iex(1)> product_prices = %{apple: 0.5, orange: 0.7, coconut: 1}
%{apple: 0.5, coconut: 1, orange: 0.7}
iex(2)> Map.to_list(product_prices) <1>
[apple: 0.5, coconut: 1, orange: 0.7]
iex(3)> Map.values(product_prices) <2>
[0.5, 1, 0.7]
iex(4)> Map.split(product_prices, [:orange, :apple]) <3>
{%{apple: 0.5, orange: 0.7}, %{coconut: 1}}
iex(5)> a = Map.delete(product_prices, :orange) <4>
%{apple: 0.5, coconut: 1}
iex(6)> b = Map.drop(product_prices, [:apple, :organge]) <5>
%{coconut: 1, orange: 0.7}
iex(7)> additional_prices = %{banana: 0.4, pineapple: 1.2}
%{banana: 0.4, pineapple: 1.2}
iex(8)> Map.merge(product_prices, additional_prices) <6>
%{apple: 0.5, banana: 0.4, coconut: 1, orange: 0.7, pineapple: 1.2}
iex(9)> c = Map.put(product_prices, :potato, 0.2) <7>
%{apple: 0.5, coconut: 1, orange: 0.7, potato: 0.2}
----
<1> `Map.to_list/1` converts a Map into a List.
<2> `Map.values/1` returns the values of a Map.
<3> `Map.split/2` splits a given map into two new maps. The first one contains all the key-value pairs which are requested by a list (e.g. `[:orange, :apple]`)
<4> `Map.delete/2` deletes a specific key-value pair in a Map.
<5> `Map.drop/2` deletes a list of key-value pairs in a Map.
<6> `Map.merge/2` merges two Maps.
<7> `Map.put/2` adds a key-value pair to a Map.

#### Structs
indexterm:["Struct"]

A Struct is a fancy Map with a couple of extra features. To define a 
Struct you have to use the `defstruct` construct:

[source,elixir]
----
iex(1)> defmodule Product do <1>
...(1)>   defstruct name: nil, price: 0 <2>
...(1)> end
{:module, Product,
 <<70, 79, 82, 49, 0, 0, 6, 192, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 184,
   0, 0, 0, 18, 14, 69, 108, 105, 120, 105, 114, 46, 80, 114, 111, 100, 117, 99,
   116, 8, 95, 95, 105, 110, 102, 111, 95, ...>>, %Product{name: nil, price: 0}}
iex(2)> %Product{}
%Product{name: nil, price: 0}
iex(3)> apple = %Product{name: "Apple", price: 0.5} <3>
%Product{name: "Apple", price: 0.5}
iex(4)> apple
%Product{name: "Apple", price: 0.5}
iex(5)> apple.price
0.5
----
<1> We define a new Struct with the name `Product` and the keys `name` and `price`.
<2> We define default values.
<3> We define a new Product Struct and set all values.

A Struct guarantees that only the defined fields are allowed:

[source,elixir]
----
iex(6)> apple.description <1>
** (KeyError) key :description not found in: %Product{name: "Apple", price: 0.5}

iex(6)> banana = %Product{name: "Banana", weight: 0.1} <2>
** (KeyError) key :weight not found
    expanding struct: Product.__struct__/1
    iex:6: (file)
iex(6)>
----
<1> Since we didn't define a `description` field in the Struct we can not access it.
<2> Same with a new Struct. There is no `weight` field defined. Therefor we can not set it.

NOTE: Because Struct build on top of Maps they can be used with the same mechanisms.

### Pattern Matching
indexterm:["Pattern Matching"]

Pattern matching is super important in Elixir and we already used it without 
knowing so for binding values to variables.

[source,elixir]
----
iex(1)> a = 10 <1>
10
iex(2)> a
10
iex(3)> {b, c} = {10, 15} <2>
{10, 15}
iex(4)> b
10
iex(5)> c
15
iex(6)> {d, e} = 100
** (MatchError) no match of right hand side value: 100 <3>
----
<1> This is actually a pattern match. The left side of `=` will be matched to the right site if possible.
<2> Here we pattern match `{b, c}` on the left side with a tuple on the right side.
<3> Boom! Because we can not match the `{d, e}` tuple with an integer we get a `MatchError`.

Since we don't have much time I'll fast forward to match a head and tail of a
list. Because there is a special syntax for that:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"] <1>
["apple", "orange", "banana", "pineapple"]
iex(2)> [head | tail] = shopping_list <2>
["apple", "orange", "banana", "pineapple"]
iex(3)> head
"apple"
iex(4)> tail
["orange", "banana", "pineapple"]
iex(5)> [a | b] = tail <3>
["orange", "banana", "pineapple"]
iex(6)> a
"orange"
iex(7)> b
["banana", "pineapple"]
iex(8)> [first_product, second_product | tail] = shopping_list <4>
["apple", "orange", "banana", "pineapple"]
iex(9)> first_product
"apple"
iex(10)> second_product
"orange"
iex(11)> tail
["banana", "pineapple"]
iex(12)> [first_product | [second_product | tail]] = shopping_list <5>
["apple", "orange", "banana", "pineapple"]
----
<1> We match a list to the variable `shopping_list`.
<2> `[head|tail]` is the special syntax to match a head and tail of a given list.
<3> Again we match the head `a` and the tail `b` with `tail`.
<4> A bit more complex. We match agains the first and second product followed by a tail.
<5> Same result. Different syntax and logic. Pick the one you prefer.

Of course if we now that a list has a specific number of elements we can match
it directly:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)> [a, b, c, d] = shopping_list
["apple", "orange", "banana", "pineapple"]
iex(3)> a
"apple"
iex(4)> b
"orange"
iex(5)> [e, f, g] = shopping_list <1>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]
----
<1> Just checking. You get an `MatchError` if Elixir can't match both sides.

#### Matching Maps

Matching a Map works a little bit different to matching a Tuple or List. 
You can match just against the values you are interested in:

[source,elixir]
----
iex(1)> product_prices = %{apple: 0.5, orange: 0.7, pineapple: 1}
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(2)> %{orange: price} = product_prices <1>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(3)> price
0.7
iex(4)> %{orange: price1, apple: price2} = product_prices <2>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(5)> price1
0.7
iex(6)> price2
0.5
----
<1> We can just match one value.
<2> Or we can match multiples. But we don't have to match the whole Map.

#### Matching Stringparts
indexterm:["Matching Stringparts"]

Easiest explained with a code example:

[source,elixir]
----
iex(1)> user = "Stefan Wintermeyer"
"Stefan Wintermeyer"
iex(2)> "Stefan " <> last_name = user
"Stefan Wintermeyer"
iex(3)> last_name
"Wintermeyer"
----

NOTE: The left side of a `<>` operator in a match should always be a string.
Otherwise Elixir can't verify it's size.

#### Wildcard Matching
indexterm:["Pattern Matching"]

Sometimes you need the pattern matching to get a value but you don't need all
the potential values in the pattern. For those cases you can use `_` (alone or
as a prefix to a variable name). It indicates to Elixir, das you don't need that
to be bind to anything.

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)> [first_product | _tail] = shopping_list <1>
["apple", "orange", "banana", "pineapple"]
iex(3)> first_product
"apple"
iex(4)> tail <2>
** (CompileError) iex:4: undefined function tail/0

iex(4)> [head | _] = shopping_list <3>
["apple", "orange", "banana", "pineapple"]
iex(5)> head
"apple"
----
<1> We pattern match the head of `shopping_list` to `first_product`. But we don't need the tail and indicate that by prefix it with a `_`.
<2> Just double-checking. No, it is not there.
<3> We can use just a `_` too. Using `_tail` just improves a bit the code readablity. 
So everybody knows that we don't need that value but can guess what it would be.

#### Matching against a variable
indexterm:["Pattern Matching"]

Assuming I'd like to fetch the second product of a shopping_list list but only if the first product is 
an `organge`. I could do this like this:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)> ["apple", second_product | _tail] = shopping_list <1>
["apple", "orange", "banana", "pineapple"]
iex(3)> second_product
"orange"
iex(4)> ["potato", second_product | _tail] = shopping_list <2>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]
----
<1> Is this cool or not!?
<2> Just checking what happens if it doesn't match. `MatchError` is a good indicator for a missmatch.

But let's now assume that you want to match the first product against the content of the variable 
`first_product`:

[source,elixir]
----
iex(1)> shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)> product = "potato" <1>
"potato"
iex(3)> [product, second_product | _tail] = shopping_list <2>
["apple", "orange", "banana", "pineapple"]
iex(4)> product
"apple"
iex(5)> second_product
"orange"
iex(6)> product = "potato" <3>
"potato"
iex(7)> [^product, second_product | _tail] = shopping_list <4>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]

iex(7)> product = "apple" <5>
"apple"
iex(8)> [^product, second_product | _tail] = shopping_list <6>
["apple", "orange", "banana", "pineapple"]
----
<1> We bind the string `potato` to the variable `product`.
<2> Now we try to match `[product, second_product | _tail]` to `shopping_list`. 
That should result in an `MatchError` because `product` represents `potato`. 
But no `MatchError`. Because Elixir doesn't know that you want to actually use the bound 
value of `product`. It thinks that you want to bind the first element of the list to the 
variable `product`.
<3> Let's try it again.
<4> To match against the content of `product` we have to prefix it with a `^`. By doing 
so we get a `MatchError` because it doesn't match.
<5> Let's bind "apple" to `product`.
<6> Bingo! Now we got a working pattern match against a variable.

#### Pattern Matching with Functions
indexterm:["Pattern Matching with Functions"]

Pattern matching is used everywhere in Elixir. You can even use it with Functions:

[source,elixir]
----
iex(1)> defmodule Area do
...(1)>   def circle(:exact, radius) do <1>
...(1)>     3.14159265359 * radius * radius
...(1)>   end
...(1)> 
...(1)>   def circle(:normal, radius) do <2>
...(1)>     3.14 * radius * radius
...(1)>   end
...(1)> 
...(1)>   def circle(radius) do <3>
...(1)>     circle(:normal, radius)
...(1)>   end
...(1)> end
{:module, Area,
 <<70, 79, 82, 49, 0, 0, 6, 40, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...>>, {:circle, 1}}
iex(2)> Area.circle(:exact, 4)
50.26548245744
iex(3)> Area.circle(:normal, 4)
50.24
iex(4)> Area.circle(4)         
50.24
----
<1> We define a `circle/2` function which matches if the first argument is the atom `:exact`.
<2> We define a `circle/2` function which matches if the first argument is the atom `:normal`.
<3> We define a `circle/1` function which calls the `cirle/2` function with the `:normal` argument.

##### Functions with Guards
indexterm:["Guards", "Functions with Guards"]

Guards add some additional spices to pattern matching with functions. You can find 
all the details at https://hexdocs.pm/elixir/guards.html

Here are just some examples to show you the concept. Guards start with `when`:

[source,elixir]
----
iex(1)> defmodule Law do
...(1)>   def can_vote?(age) when is_integer(age) and age > 17 do <1>
...(1)>     true
...(1)>   end
...(1)> 
...(1)>   def can_vote?(age) when is_integer(age) do <2>
...(1)>     false
...(1)>   end
...(1)> end
{:module, Law,
 <<70, 79, 82, 49, 0, 0, 5, 32, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 15, 10, 69, 108, 105, 120, 105, 114, 46, 76, 97, 119, 8, 95, 95,
   105, 110, 102, 111, 95, 95, 7, 99, 111, ...>>, {:can_vote?, 1}}
iex(2)> Law.can_vote?(15)
false
iex(3)> Law.can_vote?(20)
true
iex(4)> Law.can_vote?("test") <3>
** (FunctionClauseError) no function clause matching in Law.can_vote?/1    
    
    The following arguments were given to Law.can_vote?/1:
    
        # 1
        "test"
    
    iex:2: Law.can_vote?/1
----
<1> This guard checks if the `age` argument is an integer and the value of it is bigger than 17.
<2> This guard just checks if the `age` argument is an integer.
<3> Since `"test"` is a string and not an integer no function matches this.

Sometimes it is useful to have a catch all at the end:

[source,elixir]
----
iex(1)> defmodule GuardExample do
...(1)>   def is_a_number?(value) when is_integer(value) or is_float(value) do 
...(1)>     true
...(1)>   end
...(1)> 
...(1)>   def is_a_number?(_value) do <1>
...(1)>     false
...(1)>   end
...(1)> end
{:module, GuardExample,
 <<70, 79, 82, 49, 0, 0, 5, 56, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 150,
   0, 0, 0, 15, 19, 69, 108, 105, 120, 105, 114, 46, 71, 117, 97, 114, 100, 69,
   120, 97, 109, 112, 108, 101, 8, 95, 95, ...>>, {:is_a_number?, 1}}
iex(2)> GuardExample.is_a_number?(3)
true
iex(3)> GuardExample.is_a_number?(3.14)
true
iex(4)> GuardExample.is_a_number?("one")
false
----
<1> `_value` catches everything that was not caught by the first `is_a_number?/1` definition.

### Case
indexterm:["Case"]

`case` is a controll structure which matches a given value to a couple of 
matching cases until one matches.

Let's assume we want to create a function that converts morse coded 
numbers to integers:

[source,elixir]
----
iex(1)> defmodule Morse do
...(1)>   def morse_to_number(input) do
...(1)>     case input do <1>
...(1)>       "-----" -> 0 <2>
...(1)>       ".----" -> 1
...(1)>       "..---" -> 2
...(1)>       "...--" -> 3
...(1)>       "....-" -> 4
...(1)>       "....." -> 5
...(1)>       "-...." -> 6
...(1)>       "--..." -> 7
...(1)>       "---.." -> 8
...(1)>       "----." -> 9
...(1)>       _ -> :error <3>
...(1)>     end
...(1)>   end
...(1)> end
{:module, Morse,
 <<70, 79, 82, 49, 0, 0, 6, 240, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 141,
   0, 0, 0, 14, 12, 69, 108, 105, 120, 105, 114, 46, 77, 111, 114, 115, 101, 8,
   95, 95, 105, 110, 102, 111, 95, 95, 7, ...>>, {:morse_to_number, 1}}
iex(2)> Morse.morse_to_number("-....") <4>
6
----
<1> After `case` comes the value we want to check.
<2> `"-----"` is the expression we want to match to return a 0.
<3> `_` is the catch all in case nothing matched yet. In this case return an `:error` atom.
<4> It works. :-)

Of course we could solve this problem just with functions too. It's up to you 
what makes most sense in a given situation.

### if and unless
indexterm:["if", "unless", "else"]

`if` and `unless` are the classics in any programming language. The following 
examples will show how to use them:

[source,elixir]
----
iex(1)> if 1 == 1 do
...(1)>   "Bingo!"
...(1)> else
...(1)>   "Negative"
...(1)> end
"Bingo!"
iex(2)> unless true do
...(2)>   "Never"
...(2)> end
nil
----

Sometimes you see a one line short form:

[source,elixir]
----
iex(3)> if 1 == 1, do: "Bingo!"
"Bingo!"
----

NOTE: Most Elixir developers prefer `case` over `if` or `unless`. 
 
### Immutability
indexterm:["Immutability"]

Probably you have already heard about immutability in Elixir. What's that about?

A variable points to a specific part of the memory where the data is stored. In
many programming languages that data can be changed to update a variable. In
Elixir it can not be changed. So that doesn't mean that you can't rebind a
variable to a different value but that this new value gets a new piece of memory
and doesn't overwrite the old memory. Once a function returns a result and
therefor has finished it's work everything gets garbage collected (wiped blank).

Why is that important at all? With immutable variables we can be absolutly sure
that other processes can not change their values while running parallel tasks.
That has a massive effect. At the end it means that your Phoenix application can
run on multiple CPUs on the same server in parallel. It even means that your
Phoenix application can share multiple CPUs on serveral nodes of a
server-cluster in your data center. It makes Elixir extremly scalable and save.

But doesn't that make your application slower? Funny thing: No. This way is 
actually faster. It is not efficiant to change data in memory.

But don't worry. It is not as complicated as it sounds. Everytime you use a
variable it uses the value of that moment in time. It will not be effected/changed
afterwords:

[source,elixir]
----
iex(1)> product = "Orange"
"Orange"
iex(2)> test1 = fn -> IO.puts(product) end <1>
#Function<21.126501267/0 in :erl_eval.expr/5>
iex(3)> product = "Apple"
"Apple"
iex(4)> test2 = fn -> IO.puts(product) end
#Function<21.126501267/0 in :erl_eval.expr/5>
iex(5)> product = "Pineapple"
"Pineapple"
iex(6)> test3 = fn -> IO.puts(product) end
#Function<21.126501267/0 in :erl_eval.expr/5>
iex(7)> product = "Banana"
"Banana"
iex(8)> test1.() <2>
Orange
:ok
iex(9)> test2.()
Apple
:ok
iex(10)> test3.()
Pineapple
:ok
iex(11)> IO.puts(product)
Banana
:ok
----
<1> Those anonymous functions may run on totally different CPUs. The life in their own little universe.
<2> The value of `product` has changed multiple times. But for `test1.()` it is the value from that point in time when we created the function.

### Sigils
indexterm:["Sigils"]

Until now encapsulated Strings in double quotes and we haven't talked about char
lists at all (IMO not needed for a beginners introduction). But there is one more 
mechanism to represent texts. They are called `Sigils` and start with a `~` (tilde) 
character which is followed by on letter which indicates what kind of sigil it is. 
After that you can use a couple of different delimiters:

[source,elixir]
----
~r/example text/
~r|example text|
~r"example text"
~r'example text'
~r(example text)
~r[example text]
~r{example text}
~r<example text>
----

NOTE: Elixir provides different delimiters for sigils so that you can write
literals without escaped delimiters.

#### Regular expressions
indexterm:["Regular expression"]

`~r` marks a [regular expression](https://en.wikipedia.org/wiki/Regular_expression):

[source,elixir]
----
iex(1)> regex = ~r/bcd/
~r/bcd/
iex(2)> "abcde" =~ regex
true
iex(3)> "efghi" =~ regex
false
iex(4)> regex = ~r/stef/i <1>
~r/stef/i
iex(5)> "Stefan" =~ regex
true
----
<1> Modifier are supported too. For a complete list have a look at https://hexdocs.pm/elixir/Regex.html

#### String
indexterm:["String"]

You can use the `~s` sigil to generate a string:

[source,elixir]
----
iex(1)> example = ~s(WOW! "double" and 'single' quotes without escaping)
"WOW! \"double\" and 'single' quotes without escaping"
iex(2)> IO.puts(example)
WOW! "double" and 'single' quotes without escaping
:ok
----

Sigils support heredocs too. You can use triple double- or single-quotes as separatos:

[source,elixir]
----
iex(1)> example_text = ~s"""
...(1)> This is an example text.
...(1)> Multiple lines are not a problem.
...(1)> """
"This is an example text.\nMultiple lines are not a problem.\n"
iex(2)> IO.puts(example_text)
This is an example text.
Multiple lines are not a problem.

:ok
----

#### Word lists
indexterm:["Word lists"]

The `~w` sigil is a useful way to generate lists of words:

[source,elixir]
----
iex(1)> shopping_cart = ~w(apple orange banana)
["apple", "orange", "banana"]
iex(2)> shopping_cart_atoms = ~w(apple orange banana)a <1>
[:apple, :orange, :banana]
----
<1> The `a` modifier tells Elixir to generate a list of atoms and not strings.

#### Date and Time

Elixir provides a couple of good to go time related [structs](Struct) which 
all have their own sigil.

##### Date
indexterm:["Date"]

Elixir provides a `%Date{}` struct that contains the following fields:

- `year`
- `month`
- `day`
- `calendar`

With the `~D` sigil you can create new `%Date{}` struct:

[source,elixir]
----
iex(1)> birthday = ~D[1973-03-23]
~D[1973-03-23]
iex(2)> birthday.day
23
iex(3)> birthday.month
3
iex(4)> birthday.year
1973
----

##### Time
indexterm:["Time"]

Elixir provides a `%Time{}` struct that contains the following fields:

- `hour`
- `minute`
- `second`
- `microsecond`
- `calendar`

With the `~T` sigil you can create new `%Time{}` struct:

[source,elixir]
----
iex(1)> now = ~T[09:29:00.0]
~T[09:29:00.0]
iex(2)> now.hour
9
----

##### NaiveDateTime
indexterm:["NaiveDateTime"]

The `%NaiveDateTime{}` struct mixes `%Date{}` with `%Time{}`.

With the `~N` sigil you can create new `%NaiveDateTime{}` struct:

[source,elixir]
----
iex(1)> timestamp = ~N[2020-05-08 09:48:00]
~N[2020-05-08 09:48:00]
----

##### DateTime
indexterm:["DateTime"]

The `%DateTime{}` struct adds a timezone to a `%NaiveDateTime{}`.

With the `~U` sigil you can create new `%NaiveDateTime{}` struct:

[source,elixir]
----
iex(4)> timestamp = ~U[2029-05-08 09:59:03Z]
~U[2029-05-08 09:59:03Z]
----

NOTE: Find more information about timezones and DateTime at https://hexdocs.pm/elixir/DateTime.html

### Recursion
indexterm:["Recursion"]

Recursions are magic and can be a dangerous trap at the same time. 
Because of immutability they are more important in Elixir than in 
other objectoriented programming languages.

Let's write a function recursion function which provides a countdown:

[source,elixir]
----
iex(1)> defmodule Example do
...(1)>   def countdown(1) do <1>
...(1)>     IO.puts "1" <2>
...(1)>   end
...(1)> 
...(1)>   def countdown(n) when is_integer(n) and n > 1 do <3>
...(1)>     IO.puts Integer.to_string(n) <4>
...(1)>     countdown(n - 1) <5>
...(1)>   end
...(1)> end
{:module, Example,
 <<70, 79, 82, 49, 0, 0, 5, 188, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 166,
   0, 0, 0, 17, 14, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 8, 95, 95, 105, 110, 102, 111, 95, ...>>, {:countdown, 1}}
iex(2)> Example.countdown(4) <6>
4
3
2
1
:ok
----
<1> If `countdown/1` is called with the argument `1` this is the best match.
<2> We call `IO.puts("1")` to print 1 to STDOUT.
<3> If `countdown/1` is called with an integer bigger than 1 as an argument this function matches.
<4> We either have to use `Integer.to_string(n)` (we could to a "#{n}" too) to print that integer to STDOUT.
<5> We recursively decrese `n` by 1 and call `countdown/1` with that new number.
<6> It works!

Here's a different example where we calculate the sum of a list of integers:

[source,elixir]
----
iex(1)> defmodule Example do
...(1)>   def sum([]) do <1>
...(1)>     0
...(1)>   end
...(1)> 
...(1)>   def sum([head | tail]) do <2>
...(1)>     head + sum(tail) <3>
...(1)>   end
...(1)> end
{:module, Example,
 <<70, 79, 82, 49, 0, 0, 5, 12, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 127,
   0, 0, 0, 14, 14, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 8, 95, 95, 105, 110, 102, 111, 95, ...>>, {:sum, 1}}
iex(2)> Example.sum([10, 8, 12, 150]) <4>
180
iex(3)> [head | tail] = [150] <5>
[150]
iex(4)> tail
[]
----
<1> The sum of an empty list is 0.
<2> We pattern match a list and split it into a `head` and a `tail`.
<3> We add the current `head` to the sum of the `tail`.
<4> It works!
<5> This is just to show how Elixir handles the case of a list with one element.

You can use the same concept to transform every element of a list. Let's assume 
we want to double the value of every element of a list:

[source,elixir]
----
iex(1)> defmodule Example do
...(1)>   def double([]) do <1>
...(1)>     []
...(1)>   end
...(1)> 
...(1)>   def double([head | tail]) do
...(1)>     [head * 2 | double(tail)] <2>
...(1)>   end
...(1)> end
{:module, Example,
 <<70, 79, 82, 49, 0, 0, 5, 40, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 14, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 8, 95, 95, 105, 110, 102, 111, 95, ...>>, {:double, 1}}
iex(2)> Ex
Example      Exception    
iex(2)> Example.double([10, 5, 999])
[20, 10, 1998]
----
<1> We again start with the most simple match. An empty list. That will result in an empty list.
<2> The `[head | tail]` syntax works both ways. We can use it to build a list too.

#### To to find a good recursion

Unless you are doing this every day you will see problems where you know that a
recursion is a good solution but you just can't think of a recursion for it. 

Let me share a pro tip for these situations: https://www.google.com and 
https://stackoverflow.com are my life-saver in such situations. No embarrassment!

During this book we will work with recursions. So you'll get a better feeling for 
it.

